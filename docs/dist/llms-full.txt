# Batua

> Easy to integrate embedded smart account secured by passkeys

## Batch Transactions

One of the key benefits of using smart accounts is the ability to batch multiple transactions into a single operation. This reduces gas costs and improves user experience by requiring only one signature for multiple actions.

### Using useSendCalls

Batua supports the experimental `useSendCalls` hook from wagmi for batch transactions:

```tsx
import { useSendCalls, useWaitForCallsStatus } from "wagmi/experimental"
import { useAccount } from "wagmi"
import { encodeFunctionData, erc20Abi, parseUnits } from "viem"

const account = useAccount()
const { sendCalls, data: callStatus } = useSendCalls()

const { data: callReceipts } = useWaitForCallsStatus({
    id: callStatus?.id
})

const callSucceeded = callReceipts?.status === "success"
const callPending = callReceipts?.status === "pending"

if (callSucceeded) {
    const transactionHash = callReceipts.receipts[0].transactionHash
}
```

### Example: Batch ERC-20 Operations

Here's a complete example of batching multiple ERC-20 operations:

```tsx
import { useCallback } from "react"
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts"

const sendBatchTransactionCallback = useCallback(async () => {
    if (!account.address) return

    // Generate random addresses for demo
    const randomAddressOne = privateKeyToAccount(generatePrivateKey()).address
    const randomAddressTwo = privateKeyToAccount(generatePrivateKey()).address

    sendCalls({
        calls: [
            {
                to: TEST_ERC20_TOKEN_ADDRESS,
                data: encodeFunctionData({
                    abi: erc20Abi,
                    functionName: "transfer",
                    args: [randomAddressOne, parseUnits("1", 6)]
                })
            },
            {
                to: TEST_ERC20_TOKEN_ADDRESS,
                data: encodeFunctionData({
                    abi: erc20Abi,
                    functionName: "transfer",
                    args: [randomAddressTwo, parseUnits("1", 6)]
                })
            }
        ]
    })
}, [account.address, sendCalls])
```

### Monitoring Batch Status

You can monitor the status of your batch transactions:

```tsx
// Check if batch is pending
if (callReceipts?.status === "pending") {
    console.log("Batch transaction is pending...")
}

// Check if batch succeeded
if (callReceipts?.status === "success") {
    console.log("Batch transaction succeeded!")
    // Access individual transaction receipts
    callReceipts.receipts.forEach((receipt, index) => {
        console.log(`Transaction ${index + 1}:`, receipt.transactionHash)
    })
}

// Check if batch failed
if (callReceipts?.status === "reverted") {
    console.log("Batch transaction failed")
}
```

### Benefits of Batch Transactions

#### Gas Efficiency

* **Reduced overhead**: Only one transaction fee instead of multiple
* **Lower total cost**: Batching operations can significantly reduce gas costs
* **Atomic execution**: All operations succeed or fail together

#### Better UX

* **Single signature**: Users only need to approve once
* **Faster execution**: All operations happen in one block
* **Simplified flow**: Fewer confirmation dialogs

#### Use Cases

Common scenarios where batch transactions are beneficial:

1. **Multi-token transfers**: Send multiple tokens in one transaction
2. **DeFi operations**: Approve and swap tokens atomically
3. **NFT operations**: Mint multiple NFTs or transfer multiple tokens
4. **Contract interactions**: Call multiple contract functions together

### Error Handling

When working with batch transactions, implement proper error handling:

```tsx
const handleBatchTransaction = useCallback(async () => {
    try {
        if (!account.address) {
            throw new Error("Wallet not connected")
        }

        await sendCalls({
            calls: [
                // Your batch operations here
            ]
        })
    } catch (error) {
        console.error("Batch transaction failed:", error)
        // Handle error appropriately
    }
}, [account.address, sendCalls])
```

### Next Steps

* [Try batch transactions](/try-batua) in our interactive demo
* Learn about [customizing Batua](/customization)
* Explore more [usage examples](/usage)


## Customization

Batua is built with shadcn/ui components, which means it automatically inherits your application's theme and can be easily customized to match your brand.

### Theme Integration

Since Batua uses shadcn/ui components, it will automatically match your existing theme:

* **Colors**: Uses your CSS custom properties for colors
* **Typography**: Inherits your font settings
* **Spacing**: Follows your design system
* **Dark/Light mode**: Automatically supports theme switching

### Visual Customizer

For easy visual customization, use our online customizer tool:

[**Customize Batua â†’**](https://tweak.batua.sh/)

The customizer allows you to:

* Adjust colors and styling
* Preview changes in real-time
* Generate custom CSS
* Download customized components

### Manual Customization

#### Styling Components

You can override Batua's styles by targeting its CSS classes:

```css
/* Custom button styling */
.batua-connect-button {
    background: linear-gradient(45deg, #your-brand-color, #secondary-color);
    border-radius: 12px;
    font-weight: 600;
}

/* Custom modal styling */
.batua-modal {
    border-radius: 16px;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
}
```

#### CSS Custom Properties

Batua respects your CSS custom properties. Update these to change the appearance:

```css
:root {
    --batua-primary: #your-primary-color;
    --batua-secondary: #your-secondary-color;
    --batua-background: #your-background-color;
    --batua-foreground: #your-text-color;
    --batua-border: #your-border-color;
    --batua-radius: 8px;
}
```

### Component Customization

#### Custom Connect Button

You can create a custom connect button while still using Batua's functionality:

```tsx
import { useConnect } from "wagmi"

function CustomConnectButton() {
    const { connectors, connect } = useConnect()
    const batuaConnector = connectors.find(c => c.name === "Batua")
    
    return (
        <button
            onClick={() => batuaConnector && connect({ connector: batuaConnector })}
            className="your-custom-button-classes"
        >
            <YourCustomIcon />
            Connect with Passkey
        </button>
    )
}
```

#### Custom Modal Content

Customize the connection modal by wrapping Batua's components:

```tsx
import { BatuaModal } from "@/components/ui/batua"

function CustomBatuaModal() {
    return (
        <BatuaModal>
            <div className="custom-header">
                <YourLogo />
                <h2>Connect to {yourAppName}</h2>
            </div>
            <BatuaModal.Content />
            <div className="custom-footer">
                <p>Secured by passkeys</p>
            </div>
        </BatuaModal>
    )
}
```

### Branding Options

#### Logo Integration

Add your logo to the Batua interface:

```tsx
const batuaConfig = {
    branding: {
        logo: "/your-logo.svg",
        name: "Your App Name",
        colors: {
            primary: "#your-primary-color",
            secondary: "#your-secondary-color"
        }
    }
}
```

#### Custom Messages

Customize user-facing messages:

```tsx
const batuaConfig = {
    messages: {
        connecting: "Connecting to your passkey...",
        connected: "Successfully connected!",
        error: "Connection failed. Please try again."
    }
}
```

### Advanced Customization

#### Custom Hooks

Create custom hooks that wrap Batua's functionality:

```tsx
import { useConnect, useAccount } from "wagmi"

export function useBatuaConnection() {
    const { connectors, connect, isPending } = useConnect()
    const { isConnected } = useAccount()
    
    const batuaConnector = connectors.find(c => c.name === "Batua")
    
    const connectBatua = () => {
        if (batuaConnector) {
            connect({ connector: batuaConnector })
        }
    }
    
    return {
        connectBatua,
        isConnecting: isPending,
        isConnected,
        isAvailable: !!batuaConnector
    }
}
```

#### Custom Error Handling

Implement custom error handling and user feedback:

```tsx
import { useConnect } from "wagmi"
import { toast } from "your-toast-library"

function ConnectWithErrorHandling() {
    const { connect, error } = useConnect()
    
    useEffect(() => {
        if (error) {
            toast.error(`Connection failed: ${error.message}`)
        }
    }, [error])
    
    // Your connect logic here
}
```

### Best Practices

#### Accessibility

Ensure your customizations maintain accessibility:

```tsx
<button
    onClick={connectBatua}
    aria-label="Connect wallet using passkey authentication"
    className="focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
>
    Connect Wallet
</button>
```

#### Responsive Design

Make sure your customizations work across devices:

```css
.batua-modal {
    width: 100%;
    max-width: 400px;
    margin: 0 auto;
}

@media (max-width: 640px) {
    .batua-modal {
        margin: 1rem;
        max-width: calc(100% - 2rem);
    }
}
```

### Next Steps

* [Try your customizations](/try-batua) in our interactive demo
* Learn about [batch transactions](/batch-transactions)
* Check out the [usage examples](/usage)


## Getting Started

Batua is a React-based embedded smart account solution secured by passkeys. It provides an easy way to integrate smart account functionality into your application with support for transaction sponsoring, batch transactions, and seamless theme integration.

### What is Batua?

Batua is an embedded smart account wallet that:

* Uses **passkeys** for secure authentication (no seed phrases needed)
* Supports **transaction sponsoring** through paymasters
* Enables **batch transactions** for better UX
* Integrates seamlessly with your app's theme via **shadcn**
* Works with popular libraries like **wagmi**, **viem**, **ethers**, **privy**, and **dynamic**
* Gives you **complete code ownership** - no external dependencies

### How it Works

1. **Passkey Authentication**: Users authenticate using their device's built-in biometric authentication (Face ID, Touch ID, Windows Hello, etc.)
2. **Smart Account Creation**: A smart account is created and controlled by the passkey
3. **EIP-6963 Compatibility**: Batua appears as a regular wallet in your dApp, compatible with all existing wallet connection libraries
4. **Transaction Sponsoring**: Optionally sponsor user transactions through Pimlico's paymaster service
5. **Batch Operations**: Send multiple transactions in a single batch for better efficiency

### Why Choose Batua?

#### For Users

* **No seed phrases** - authenticate with biometrics
* **Sponsored transactions** - no need to hold ETH for gas
* **Faster transactions** - batch multiple operations
* **Secure** - passkeys are more secure than traditional private keys

#### For Developers

* **Easy integration** - works with existing wallet connection code
* **Complete control** - own the entire codebase
* **Theme consistency** - matches your app's design
* **Flexible** - works with any React framework

### Next Steps

Ready to integrate Batua? Continue to the [Installation](/installation) guide to get started.


## Installation

### Install using the CLI

To install Batua using the `shadcn` CLI, use the `add` command followed by the URL of the registry item.

:::code-group
```bash [pnpm]
pnpm dlx shadcn@latest add https://batua.sh/install
```

```bash [npm]
npx shadcn@latest add https://batua.sh/install
```

```bash [yarn]
yarn dlx shadcn@latest add https://batua.sh/install
```

```bash [bun]
bunx --bun shadcn@latest add https://batua.sh/install
```
:::

### What gets installed?

The installation will add the following to your project:

* **Batua component** - The main wallet component
* **Required dependencies** - All necessary packages for smart account functionality
* **Type definitions** - TypeScript support out of the box
* **Styling** - Tailwind CSS classes that match your theme

### Prerequisites

Before installing Batua, make sure you have:

1. **React 18+** - Batua is built for modern React
2. **shadcn/ui setup** - Your project should have shadcn/ui configured
3. **Tailwind CSS** - Required for styling
4. **TypeScript** (recommended) - For the best development experience

### Next Steps

After installation, you'll need to:

1. [Set up your Passkey Server](/usage#step-1-set-up-passkey-server)
2. [Configure Batua in your app](/usage#step-2-implement-batua)
3. [Test the integration](/try-batua)

Continue to the [Usage](/usage) guide for detailed setup instructions.


## Try Batua

Experience Batua in action with our interactive demo. Test all the features including passkey authentication, transaction sponsoring, and batch transactions.

### Interactive Demo

Our demo showcases all of Batua's key features:

* **Passkey Authentication**: Connect using your device's biometric authentication
* **Transaction Sponsoring**: Send transactions without holding ETH for gas
* **Batch Transactions**: Execute multiple operations in a single transaction
* **Real-time Balance Updates**: See your test token balance update in real-time

[**Launch Interactive Demo â†’**](/)

### What You Can Test

#### 1. Wallet Connection

* Connect using passkeys (Face ID, Touch ID, Windows Hello, etc.)
* No seed phrases or private keys needed
* Secure authentication using your device's built-in security

#### 2. Single Transactions

* Mint test ERC-20 tokens
* See transaction status and hash
* Experience sponsored transactions (no gas fees)

#### 3. Batch Transactions

* Send multiple token transfers in one transaction
* Approve and transfer tokens atomically
* Experience the efficiency of batched operations

#### 4. Real-time Updates

* Balance updates every 5 seconds
* Transaction status monitoring
* Live feedback on all operations

### Demo Environment

The demo runs on **Sepolia testnet** with:

* **Test ERC-20 Token**: A custom token for testing transfers
* **Sponsored Transactions**: All transactions are sponsored (no gas fees)
* **Safe Environment**: No real funds at risk

### Getting Test Tokens

The demo includes a "Mint test erc20 tokens" button that will:

1. Create a transaction to mint 100 test tokens
2. Add them to your smart account balance
3. Enable you to test batch transfers

### Understanding the Code

The demo is built with the same code you'll use in your application:

```tsx
// Connect to Batua
const { connectors, connect } = useConnect()
const batuaConnector = connectors.find(c => c.name === "Batua")

// Send batch transactions
const { sendCalls } = useSendCalls()
sendCalls({
    calls: [
        // Multiple operations here
    ]
})
```

### Troubleshooting

#### Passkey Issues

* **Not supported**: Ensure your device supports passkeys
* **Registration failed**: Try using a different browser or device
* **Authentication failed**: Make sure biometrics are enabled

#### Transaction Issues

* **Transaction pending**: Wait for confirmation (usually 10-30 seconds on Sepolia)
* **Transaction failed**: Check the console for error details
* **Balance not updating**: Wait for the next balance refresh (every 5 seconds)

### Next Steps

After trying the demo:

1. **Install Batua** in your project using the [installation guide](/installation)
2. **Configure** your setup following the [usage instructions](/usage)
3. **Customize** the appearance to match your brand using our [customization guide](/customization)
4. **Implement batch transactions** using our [batch transactions guide](/batch-transactions)

### Feedback

Found an issue or have suggestions? We'd love to hear from you:

* [GitHub Issues](https://github.com/pimlicolabs/batua/issues)
* [GitHub Discussions](https://github.com/pimlicolabs/batua/discussions)

***

Ready to integrate Batua into your application? Start with our [Getting Started](/getting-started) guide.


## Usage

### Step 1: Set up Passkey Server

Before implementing Batua, you need to configure your passkey server:

1. Go to [https://dashboard.pimlico.io/passkey-server](https://dashboard.pimlico.io/passkey-server)
2. Create a new passkey server configuration
3. Configure your domain and settings
4. Note down your configuration details for the next step

### Step 2: Implement Batua

After installing Batua, you can integrate it into your application:

```tsx
import { Batua } from "@/lib/batua"
import { sepolia } from "viem/chains"
import { http } from "viem/transport"

const pimlicoApiKey = "your-pimlico-api-key"

Batua.create({
    rpc: {
        transports: {
            [sepolia.id]: http("https://ethereum-sepolia-rpc.publicnode.com")
        }
    },
    // optional
    paymaster: {
        transports: {
            [sepolia.id]: http(
                `https://api.pimlico.io/v2/${sepolia.id}/rpc?apikey=${pimlicoApiKey}`
            )
        },
        // optional
        context: {
            sponsorshipPolicyId: process.env.NEXT_PUBLIC_SPONSORSHIP_POLICY_ID
        }
    },
    bundler: {
        transports: {
            [sepolia.id]: http(
                `https://api.pimlico.io/v2/${sepolia.id}/rpc?apikey=${pimlicoApiKey}`
            )
        }
    }
})
```

### Configuration Options

#### Required Configuration

* **rpc.transports**: RPC endpoints for each chain you want to support
* **bundler.transports**: Bundler endpoints for UserOperation submission

#### Optional Configuration

* **paymaster.transports**: Paymaster endpoints for transaction sponsoring
* **paymaster.context**: Additional context for paymaster (like sponsorship policy ID)

### Integration with Wagmi

After creating Batua, you can use your regular wagmi/ethers libraries and Batua will behave like an injected wallet compatible with EIP-6963.

```tsx
import { useConnect } from "wagmi"

function ConnectWallet() {
    const { connectors, connect } = useConnect()
    
    return (
        <div>
            {connectors.map((connector) => (
                <button
                    key={connector.uid}
                    onClick={() => connect({ connector })}
                >
                    {connector.name}
                </button>
            ))}
        </div>
    )
}
```

Batua will appear as one of the available connectors with the name "Batua".

### Environment Variables

For production use, make sure to set up your environment variables:

```bash
NEXT_PUBLIC_PIMLICO_API_KEY=your-pimlico-api-key
NEXT_PUBLIC_SPONSORSHIP_POLICY_ID=your-sponsorship-policy-id
```

### Next Steps

* Learn about [Batch Transactions](/batch-transactions)
* [Customize Batua](/customization) to match your brand
* [Try Batua](/try-batua) in our interactive demo

