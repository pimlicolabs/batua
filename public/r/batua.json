{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "batua",
  "type": "registry:block",
  "title": "Batua",
  "description": "A wallet provider for wagmi with support for account abstraction.",
  "dependencies": [
    "ox@^0.6.12",
    "permissionless@^0.2.40",
    "zustand@^5.0.3",
    "viem@^2.25.0",
    "mipd@^0.0.7",
    "@sinclair/typebox@^0.34.33",
    "idb-keyval@^6.2.1",
    "react@^19.0.0",
    "react-dom@^19.0.0",
    "lucide-react@^0.471.1"
  ],
  "registryDependencies": [
    "dialog",
    "button"
  ],
  "files": [
    {
      "path": "registry/batua/batua/components/Login.tsx",
      "content": "\"use client\"\nimport { WebAuthnP256 } from \"ox\"\nimport type { QueuedRequest, Internal } from \"@/registry/batua/batua/type\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n    Dialog,\n    DialogContent,\n    DialogDescription,\n    DialogHeader,\n    DialogTitle\n} from \"@/components/ui/dialog\"\nimport { AlertCircle, LogIn } from \"lucide-react\"\nimport { Provider } from \"ox\"\nimport { toKernelSmartAccount } from \"permissionless/accounts\"\nimport { getClient } from \"@/registry/batua/batua/helpers/getClient\"\nimport {\n    createWebAuthnCredential,\n    entryPoint07Address,\n    toWebAuthnAccount\n} from \"viem/account-abstraction\"\nimport { createPasskeyServerClient } from \"permissionless/clients/passkeyServer\"\nimport * as Key from \"@/registry/batua/batua/key\"\nimport { useCallback, useState } from \"react\"\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\nimport { Errors } from \"ox\"\nimport { BaseError } from \"viem\"\n\nexport const Login = ({\n    onComplete,\n    queueRequest,\n    internal\n}: {\n    onComplete: (args: {\n        queueRequest: QueuedRequest\n    }) => void | Promise<void>\n    queueRequest: QueuedRequest\n    internal: Internal\n}) => {\n    const [error, setError] = useState<string | null>(null)\n    const [isShaking, setIsShaking] = useState(false)\n\n    const triggerShake = useCallback(() => {\n        setIsShaking(true)\n        setTimeout(() => setIsShaking(false), 500) // Reset shake after animation completes\n    }, [])\n\n    const createCredential = useCallback(async () => {\n        const client = getClient({\n            internal,\n            chainId: internal.store.getState().chain.id\n        })\n        const credential = await (async () => {\n            try {\n                const passkeyServerClient = createPasskeyServerClient({\n                    chain: client.chain,\n                    transport:\n                        internal.config.transports[client.chain.id].bundler\n                })\n\n                const userName = crypto.randomUUID()\n\n                const credential = await createWebAuthnCredential(\n                    // Start the registration process\n                    await passkeyServerClient.startRegistration({\n                        context: {\n                            // userName that will be shown to the user when creating the passkey\n                            userName\n                        }\n                    })\n                )\n\n                // Verify the registration\n                const verifiedCredential =\n                    await passkeyServerClient.verifyRegistration({\n                        credential,\n                        context: {\n                            // userName that will be shown to the user when creating the passkey\n                            userName\n                        }\n                    })\n\n                if (!verifiedCredential.success) {\n                    throw new Error(\"Failed to verify registration\")\n                }\n\n                return {\n                    id: verifiedCredential.id,\n                    publicKey: verifiedCredential.publicKey\n                }\n            } catch (error) {\n                onComplete({\n                    queueRequest: {\n                        request: queueRequest.request,\n                        status: \"error\",\n                        error: new Provider.UserRejectedRequestError()\n                    }\n                })\n            }\n        })()\n        if (!credential) return\n        const smartAccount = await toKernelSmartAccount({\n            client,\n            version: \"0.3.1\",\n            owners: [toWebAuthnAccount({ credential })],\n            entryPoint: {\n                address: entryPoint07Address,\n                version: \"0.7\"\n            }\n        })\n        internal.store.setState((x) => ({\n            ...x,\n            accounts: [\n                ...x.accounts,\n                {\n                    address: smartAccount.address,\n                    key: Key.fromWebAuthnP256({\n                        credential: credential,\n                        //todo: use rpId\n                        rpId: undefined\n                    }),\n                    type: \"smartAccount\"\n                }\n            ]\n        }))\n        onComplete({\n            queueRequest: {\n                request: queueRequest.request,\n                status: \"success\",\n                result: [smartAccount.address]\n            }\n        })\n    }, [internal, onComplete, queueRequest])\n\n    const signIn = useCallback(async () => {\n        try {\n            const client = getClient({\n                internal,\n                chainId: internal.store.getState().chain.id\n            })\n            const passkeyServerClient = createPasskeyServerClient({\n                chain: client.chain,\n                transport: internal.config.transports[client.chain.id].bundler\n            })\n\n            const challenge = await passkeyServerClient.startAuthentication()\n\n            const signature = await WebAuthnP256.sign(challenge)\n\n            const verifiedCredential =\n                await passkeyServerClient.verifyAuthentication({\n                    ...signature,\n                    uuid: challenge.uuid\n                })\n\n            if (!verifiedCredential.success) {\n                throw new Error(\"Failed to verify authentication\")\n            }\n\n            const credential = {\n                id: verifiedCredential.id,\n                publicKey: verifiedCredential.publicKey\n            }\n\n            const smartAccount = await toKernelSmartAccount({\n                client,\n                version: \"0.3.1\",\n                owners: [toWebAuthnAccount({ credential })],\n                entryPoint: {\n                    address: entryPoint07Address,\n                    version: \"0.7\"\n                }\n            })\n            internal.store.setState((x) => ({\n                ...x,\n                accounts: [\n                    ...x.accounts,\n                    {\n                        address: smartAccount.address,\n                        key: Key.fromWebAuthnP256({\n                            credential: credential,\n                            //todo: use rpId\n                            rpId: undefined\n                        }),\n                        type: \"smartAccount\"\n                    }\n                ]\n            }))\n            onComplete({\n                queueRequest: {\n                    request: queueRequest.request,\n                    status: \"success\",\n                    result: [smartAccount.address]\n                }\n            })\n        } catch (error) {\n            const { code, errorMessage } = (() => {\n                if (\n                    error instanceof Error &&\n                    error.message === \"Failed to verify authentication\"\n                ) {\n                    return {\n                        code: \"INVALID_SIGNATURE\",\n                        errorMessage: \"Failed to verify authentication\"\n                    }\n                }\n\n                if (\n                    error instanceof BaseError ||\n                    error instanceof Errors.BaseError\n                ) {\n                    const notAllowedError = error.walk(\n                        (e) =>\n                            e instanceof Error && e.name === \"NotAllowedError\"\n                    )\n\n                    if (notAllowedError) {\n                        return {\n                            code: \"NOT_ALLOWED\",\n                            errorMessage: \"User rejected the request\"\n                        }\n                    }\n\n                    const e = error.walk(\n                        (e) =>\n                            e instanceof BaseError &&\n                            e.name === \"InternalRpcError\"\n                    ) as BaseError | undefined\n\n                    if (e?.details) {\n                        return {\n                            errorMessage:\n                                e.details === \"Passkey not found\"\n                                    ? \"Invalid passkey, please try again with a different passkey or sign up\"\n                                    : \"Failed to sign in, please try using correct passkey\"\n                        }\n                    }\n                }\n\n                return {\n                    errorMessage:\n                        \"Failed to sign in, please try using correct passkey\"\n                }\n            })()\n\n            if (code === \"NOT_ALLOWED\") {\n                onComplete({\n                    queueRequest: {\n                        request: queueRequest.request,\n                        status: \"error\",\n                        error: new Provider.UserRejectedRequestError()\n                    }\n                })\n                return\n            }\n\n            setError(errorMessage)\n            triggerShake()\n            return\n        }\n    }, [internal, onComplete, queueRequest, triggerShake])\n\n    const onOpenChange = useCallback(\n        (open: boolean) => {\n            if (!open) {\n                onComplete({\n                    queueRequest: {\n                        request: queueRequest.request,\n                        status: \"error\",\n                        error: new Provider.UserRejectedRequestError()\n                    }\n                })\n            }\n        },\n        [onComplete, queueRequest]\n    )\n\n    return (\n        <Dialog open={!!queueRequest} onOpenChange={onOpenChange}>\n            <DialogContent\n                className={`sm:max-w-[425px] p-6 ${isShaking ? \"animate-shake\" : \"\"}`}\n            >\n                <DialogHeader className=\"pb-4\">\n                    <DialogTitle>Sign in</DialogTitle>\n                    <DialogDescription>\n                        Sign in to your wallet with your passkey.\n                    </DialogDescription>\n                </DialogHeader>\n\n                {error && (\n                    <Alert variant=\"destructive\" className=\"mb-4\">\n                        <AlertCircle className=\"h-4 w-4\" />\n                        <AlertDescription>{error}</AlertDescription>\n                    </Alert>\n                )}\n\n                <div className=\"grid gap-5 py-2\">\n                    <div className=\"grid grid-cols-2 items-center gap-4\">\n                        <Button type=\"submit\" onClick={signIn}>\n                            <LogIn className=\"mr-2 h-4 w-4\" />\n                            Sign in\n                        </Button>\n                        <Button\n                            variant=\"outline\"\n                            type=\"submit\"\n                            onClick={() => {\n                                setError(null)\n                                createCredential()\n                            }}\n                        >\n                            <LogIn className=\"mr-2 h-4 w-4\" />\n                            Sign up\n                        </Button>\n                    </div>\n                </div>\n            </DialogContent>\n        </Dialog>\n    )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/batua/batua/components/Main.tsx",
      "content": "import React from \"react\"\nimport type { QueuedRequest, Internal } from \"@/registry/batua/batua/type\"\nimport { Login } from \"@/registry/batua/batua/components/Login\"\nimport { SendCalls } from \"@/registry/batua/batua/components/SendCalls\"\n\nexport const Main = ({ internal }: { internal: Internal }) => {\n    const [queueRequest, setQueueRequest] =\n        React.useState<QueuedRequest | null>(null)\n\n    React.useEffect(() => {\n        const unsubscribe = internal.store.subscribe(\n            (x) => x.requestQueue,\n            (requestQueue) => {\n                const requests = requestQueue\n                    .map((x) => (x.status === \"pending\" ? x : undefined))\n                    .filter(Boolean) as readonly QueuedRequest[]\n                if (requests.length === 0) return\n                if (requests[0].request.id === queueRequest?.request.id) return\n                setQueueRequest(requests[0])\n            }\n        )\n\n        return () => {\n            unsubscribe()\n        }\n    }, [internal.store, queueRequest])\n\n    const onComplete = ({ queueRequest }: { queueRequest: QueuedRequest }) => {\n        setQueueRequest(null)\n        internal.store.setState((x) => ({\n            ...x,\n            requestQueue: x.requestQueue.map((req) =>\n                req.request.id === queueRequest.request.id ? queueRequest : req\n            )\n        }))\n    }\n\n    if (queueRequest?.request.method === \"eth_requestAccounts\") {\n        return (\n            <Login\n                internal={internal}\n                queueRequest={queueRequest}\n                onComplete={onComplete}\n            />\n        )\n    }\n\n    if (queueRequest?.request.method === \"wallet_sendCalls\") {\n        return (\n            <SendCalls\n                internal={internal}\n                queueRequest={queueRequest}\n                onComplete={onComplete}\n            />\n        )\n    }\n\n    return (\n        <div>{queueRequest ? JSON.stringify(queueRequest) : \"No request\"}</div>\n    )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/batua/batua/components/SendCalls.tsx",
      "content": "\"use client\"\nimport {\n    Dialog,\n    DialogContent,\n    DialogDescription,\n    DialogHeader,\n    DialogTitle\n} from \"@/components/ui/dialog\"\nimport type { Internal, QueuedRequest } from \"@/registry/batua/batua/type\"\nimport { Provider, RpcRequest } from \"ox\"\nimport { Button } from \"@/components/ui/button\"\nimport { toKernelSmartAccount } from \"permissionless/accounts\"\nimport { getClient } from \"@/registry/batua/batua/helpers/getClient\"\nimport { getSmartAccountClient } from \"@/registry/batua/batua/helpers/getSmartAccountClient\"\nimport {\n    entryPoint07Address,\n    toWebAuthnAccount\n} from \"viem/account-abstraction\"\nimport { useState } from \"react\"\nimport { Loader } from \"lucide-react\"\nimport { formatEther } from \"ox/Value\"\n\nexport const SendCalls = ({\n    onComplete,\n    queueRequest,\n    internal\n}: {\n    onComplete: (args: {\n        queueRequest: QueuedRequest\n    }) => void | Promise<void>\n    queueRequest: QueuedRequest\n    internal: Internal\n}) => {\n    const [sendingTransaction, setSendingTransaction] = useState(false)\n\n    const onOpenChange = (open: boolean) => {\n        if (!open) {\n            onComplete({\n                queueRequest: {\n                    request: queueRequest.request,\n                    status: \"error\",\n                    error: new Provider.UserRejectedRequestError()\n                }\n            })\n        }\n    }\n\n    const sendTransaction = async () => {\n        const requestStore = RpcRequest.createStore()\n        const request = requestStore.prepare(queueRequest.request)\n\n        if (request.method !== \"wallet_sendCalls\") {\n            throw new Error(\"Invalid request\")\n        }\n\n        const from = request.params[0].from\n        const capabilities = request.params[0].capabilities\n        const account = internal.store\n            .getState()\n            .accounts.find((account) => account.address === from)\n        if (!account) {\n            throw new Provider.UnauthorizedError()\n        }\n\n        const key = account.key\n        if (!key) {\n            throw new Provider.UnauthorizedError()\n        }\n\n        const credential = key.credential\n        if (!credential) {\n            throw new Provider.UnauthorizedError()\n        }\n\n        const client = getClient({\n            internal,\n            chainId: internal.store.getState().chain.id\n        })\n\n        setSendingTransaction(true)\n\n        const smartAccount = await toKernelSmartAccount({\n            client,\n            version: \"0.3.1\",\n            owners: [\n                toWebAuthnAccount({\n                    credential: {\n                        id: credential.id,\n                        publicKey: credential.publicKey\n                    }\n                })\n            ],\n            entryPoint: {\n                address: entryPoint07Address,\n                version: \"0.7\"\n            }\n        })\n\n        const smartAccountClient = getSmartAccountClient({\n            account: smartAccount,\n            internal,\n            capabilities,\n            chainId: internal.store.getState().chain.id\n        })\n\n        const userOpHash = await smartAccountClient.sendUserOperation({\n            callData: await smartAccountClient.account.encodeCalls(\n                request.params[0].calls.map((call) => ({\n                    to: call.to ?? \"0x\",\n                    data: call.data ?? \"0x\",\n                    value: call.value ? BigInt(call.value) : undefined\n                }))\n            )\n        })\n\n        onComplete({\n            queueRequest: {\n                request: queueRequest.request,\n                status: \"success\",\n                result: userOpHash\n            }\n        })\n\n        setSendingTransaction(false)\n    }\n\n    const calls = (queueRequest?.request.params as any)[0].calls as any\n\n    return (\n        <Dialog open={!!queueRequest} onOpenChange={onOpenChange}>\n            <DialogContent className=\"sm:max-w-[425px]\">\n                <DialogHeader>\n                    <DialogTitle>Send transaction</DialogTitle>\n                    <DialogDescription>\n                        Send a transaction from your smart account.\n                    </DialogDescription>\n                </DialogHeader>\n                <div className=\"grid gap-4 py-4\">\n                    {calls.map((call: any, index: number) => (\n                        // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n                        <div key={index} className=\"border rounded-md p-3\">\n                            <p className=\"text-sm font-medium\">\n                                To:{\" \"}\n                                <span className=\"font-mono text-xs\">\n                                    {call.to}\n                                </span>\n                            </p>\n                            <p className=\"text-sm font-medium mt-2\">\n                                Value:{\" \"}\n                                <span className=\"text-xs font-mono\">\n                                    {formatEther(call.value ?? BigInt(0))}\n                                </span>\n                            </p>\n                            <p className=\"text-sm font-medium truncate mt-2\">\n                                Data:{\" \"}\n                                <span className=\"text-xs text-muted-foreground font-mono\">\n                                    {call.data || \"0x\"}\n                                </span>\n                            </p>\n                        </div>\n                    ))}\n                    <Button\n                        type=\"submit\"\n                        onClick={sendTransaction}\n                        disabled={sendingTransaction}\n                    >\n                        {sendingTransaction && (\n                            <Loader className=\"mr-2 h-4 w-4 animate-spin\" />\n                        )}\n                        {sendingTransaction ? \"Sending...\" : \"Send transaction\"}\n                    </Button>\n                </div>\n            </DialogContent>\n        </Dialog>\n    )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/batua/batua/index.ts",
      "content": "import { type Chain, base, baseSepolia, sepolia } from \"viem/chains\"\nimport { http, type Transport } from \"viem\"\nimport type {\n    Implementation,\n    Internal,\n    State,\n    Storage\n} from \"@/registry/batua/batua/type\"\nimport { Provider } from \"@/registry/batua/batua/provider\"\nimport { local } from \"@/registry/batua/batua/implementations/local\"\nimport { createStore } from \"zustand/vanilla\"\nimport { persist, subscribeWithSelector } from \"zustand/middleware\"\nimport { idb } from \"@/registry/batua/batua/storage\"\n\nconst defaultConfig = {\n    chains: [sepolia, baseSepolia, base],\n    announceProvider: true,\n    storage: idb(),\n    transports: {\n        // TODO: Add transports for all chains\n        [sepolia.id]: {\n            rpc: http(),\n            bundler: http(`https://public.pimlico.io/v2/${sepolia.id}/rpc`)\n        },\n        [baseSepolia.id]: {\n            rpc: http(),\n            bundler: http(`https://public.pimlico.io/v2/${baseSepolia.id}/rpc`)\n        },\n        [base.id]: {\n            rpc: http(),\n            bundler: http(`https://public.pimlico.io/v2/${base.id}/rpc`)\n        }\n    },\n    implementation: local()\n} as const satisfies Config\n\nexport type Config<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = {\n    announceProvider: boolean\n    chains: chains | readonly [Chain, ...Chain[]]\n    implementation: Implementation\n    storage: Storage\n    transports: Record<\n        chains[number][\"id\"],\n        {\n            rpc: Transport\n            bundler: Transport\n            paymaster?: Transport\n        }\n    >\n}\n\nexport const Batua = {\n    create: <\n        chains extends readonly [Chain, ...Chain[]] = readonly [\n            Chain,\n            ...Chain[]\n        ]\n    >(parameters?: {\n        chains?: chains | readonly [Chain, ...Chain[]]\n        announceProvider?: boolean\n        storage?: Storage\n        implementation?: Implementation | null\n        transports?: Record<\n            chains[number][\"id\"],\n            {\n                rpc?: Transport\n                bundler?: Transport\n                paymaster?: Transport\n            }\n        >\n    }) => {\n        const config: Config = {\n            storage: parameters?.storage ?? defaultConfig.storage,\n            chains: parameters?.chains ?? defaultConfig.chains,\n            announceProvider: parameters?.announceProvider ?? true,\n            transports: parameters?.transports ?? defaultConfig.transports,\n            implementation:\n                parameters?.implementation ?? defaultConfig.implementation\n        }\n\n        let implementation = config.implementation\n\n        const store = createStore(\n            subscribeWithSelector(\n                persist<State>(\n                    (_) => ({\n                        accounts: [],\n                        chain: config.chains[0],\n                        requestQueue: []\n                    }),\n                    {\n                        name: \"batua.store\",\n                        partialize(state) {\n                            return {\n                                accounts: state.accounts.map((account) => ({\n                                    ...account,\n                                    sign: undefined\n                                    // keys: account.keys?.map((key) => ({\n                                    //     ...key,\n                                    //     privateKey:\n                                    //         typeof key.privateKey === \"function\"\n                                    //             ? undefined\n                                    //             : key.privateKey\n                                    // }))\n                                })),\n                                chain: state.chain\n                            } as unknown as State\n                        },\n                        storage: config.storage\n                    }\n                )\n            )\n        )\n\n        const internal: Internal = {\n            config,\n            id: crypto.randomUUID(),\n            getImplementation() {\n                return implementation\n            },\n            setImplementation(i) {\n                destroy?.()\n                implementation = i\n                destroy = i.setup({\n                    internal\n                })\n                return destroy\n            },\n            store\n        }\n\n        const provider = Provider.from({ internal })\n\n        let destroy = implementation.setup({\n            internal\n        })\n\n        return {\n            destroy: () => {\n                provider.destroy()\n                destroy()\n            }\n        }\n    }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/key.ts",
      "content": "import type { Hex } from \"ox\"\nimport type { Key } from \"@/registry/batua/batua/type\"\n\nexport const fromWebAuthnP256 = ({\n    credential,\n    rpId\n}: {\n    credential: {\n        id: string\n        publicKey: Hex.Hex\n    }\n    rpId: string | undefined\n}): Key => {\n    return {\n        canSign: true,\n        credential: {\n            id: credential.id,\n            publicKey: credential.publicKey\n        },\n        rpId,\n        type: \"webauthn-p256\"\n    }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/provider.ts",
      "content": "import { announceProvider } from \"mipd\"\nimport { Address, Hex, Provider as ProviderOx } from \"ox\"\nimport type { Internal } from \"@/registry/batua/batua/type\"\nimport { getClient as getClientHelper } from \"@/registry/batua/batua/helpers/getClient\"\nimport * as Rpc from \"@/registry/batua/batua/typebox/rpc\"\n\nexport const Provider = {\n    from: ({ internal }: { internal: Internal }) => {\n        const { store, getImplementation, config } = internal\n\n        function getClient(chainId_?: Hex.Hex | number | undefined) {\n            const chainId =\n                typeof chainId_ === \"string\" ? Hex.toNumber(chainId_) : chainId_\n            return getClientHelper({ internal, chainId })\n        }\n\n        const emitter = ProviderOx.createEmitter()\n        const provider = ProviderOx.from({\n            ...emitter,\n            request: async (request_) => {\n                let request: Rpc.parseRequest.ReturnType\n                try {\n                    request = Rpc.parseRequest(request_)\n                } catch (e) {\n                    const unsupportedCode = 62\n                    if ((e as any).error?.type !== unsupportedCode) throw e\n\n                    // catch unsupported methods\n                    if (\n                        (request_ as { method: string }).method.startsWith(\n                            \"wallet_\"\n                        )\n                    )\n                        throw new ProviderOx.UnsupportedMethodError()\n                    return getClient().request(request_ as any)\n                }\n\n                const state = store.getState()\n\n                switch (request.method) {\n                    case \"eth_accounts\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n                        const response = state.accounts.map(\n                            (account) => account.address\n                        )\n                        return response\n                    }\n                    case \"eth_chainId\": {\n                        const response = Hex.fromNumber(state.chain.id)\n                        return response\n                    }\n                    case \"wallet_getCapabilities\": {\n                        const value = {\n                            atomicBatch: {\n                                supported: true\n                            },\n                            // createAccount: {\n                            //     supported: true\n                            // },\n                            // permissions: {\n                            //     supported: true\n                            // },\n                            paymasterService: {\n                                supported: true\n                            }\n                        }\n\n                        const capabilities = {} as Record<Hex.Hex, typeof value>\n                        for (const chain of config.chains)\n                            capabilities[Hex.fromNumber(chain.id)] = value\n\n                        return capabilities\n                    }\n                    case \"eth_requestAccounts\": {\n                        if (state.accounts.length > 0) {\n                            return state.accounts.map(\n                                (account) => account.address\n                            )\n                        }\n                        const client = getClient()\n                        const { accounts } =\n                            await getImplementation().actions.loadAccounts({\n                                client,\n                                config,\n                                request,\n                                store\n                            })\n\n                        emitter.emit(\"connect\", {\n                            chainId: Hex.fromNumber(client.chain.id)\n                        })\n                        const response = accounts.map(\n                            (account) => account.address\n                        )\n                        return response\n                    }\n                    case \"eth_sendTransaction\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        const [{ chainId, data = \"0x\", from, to, value }] =\n                            request._decoded.params\n\n                        const client = getClient(chainId)\n\n                        if (chainId && chainId !== client.chain.id)\n                            throw new ProviderOx.ChainDisconnectedError()\n\n                        const account = state.accounts.find((account) =>\n                            Address.isEqual(account.address, from)\n                        )\n                        if (!account) throw new ProviderOx.UnauthorizedError()\n\n                        const hash =\n                            await getImplementation().actions.sendCalls({\n                                account,\n                                calls: [\n                                    {\n                                        data,\n                                        to,\n                                        value\n                                    }\n                                ],\n                                client,\n                                config,\n                                request,\n                                store\n                            })\n\n                        let txHash: Hex.Hex | undefined\n\n                        while (!txHash) {\n                            const receipts =\n                                await getImplementation().actions.getCallsStatus(\n                                    {\n                                        client,\n                                        config,\n                                        request,\n                                        store,\n                                        userOperationHash: hash,\n                                        timeout: 60_000 // 1 minute\n                                    }\n                                )\n\n                            if (receipts.status === \"CONFIRMED\") {\n                                txHash = receipts.receipts?.[0]?.transactionHash\n                            }\n                        }\n\n                        return txHash\n                    }\n                    case \"wallet_sendCalls\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        const [{ chainId, calls }] = request._decoded.params\n\n                        const from =\n                            request._decoded.params[0].from ??\n                            state.accounts[0].address\n\n                        const client = getClient(chainId)\n\n                        if (chainId && chainId !== client.chain.id)\n                            throw new ProviderOx.ChainDisconnectedError()\n\n                        const account = state.accounts.find((account) =>\n                            Address.isEqual(account.address, from)\n                        )\n                        if (!account) throw new ProviderOx.UnauthorizedError()\n\n                        const hash =\n                            await getImplementation().actions.sendCalls({\n                                account,\n                                calls,\n                                capabilities:\n                                    request._decoded.params[0]?.capabilities ??\n                                    undefined,\n                                client,\n                                config,\n                                request,\n                                store\n                            })\n\n                        return hash\n                    }\n                    case \"wallet_getCallsStatus\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        const [userOperationHash] = request._decoded.params\n\n                        const client = getClient()\n\n                        const receipts =\n                            await getImplementation().actions.getCallsStatus({\n                                client,\n                                config,\n                                request,\n                                store,\n                                userOperationHash\n                            })\n\n                        return receipts\n                    }\n                }\n            }\n        })\n\n        const setup = () => {\n            const unsubscribe_accounts = store.subscribe(\n                (state) => state.accounts,\n                (accounts) => {\n                    emitter.emit(\n                        \"accountsChanged\",\n                        accounts.map((account) => account.address)\n                    )\n                }\n            )\n\n            const unsubscribe_chain = store.subscribe(\n                (state) => state.chain,\n                (chain) => {\n                    emitter.emit(\"chainChanged\", Hex.fromNumber(chain.id))\n                }\n            )\n\n            const unAnnounce =\n                internal.config.announceProvider &&\n                typeof window !== \"undefined\"\n                    ? announceProvider({\n                          info: {\n                              name: \"Batua\",\n                              icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K\",\n                              rdns: \"pimlico.io\",\n                              uuid: internal.id\n                          },\n                          // biome-ignore lint/suspicious/noExplicitAny: viem & announceProvider has different declaration but same thing\n                          provider: provider as any\n                      })\n                    : () => {}\n            return () => {\n                unsubscribe_accounts()\n                unsubscribe_chain()\n                unAnnounce()\n            }\n        }\n\n        const destroy = setup()\n\n        return Object.assign(provider, {\n            destroy\n        })\n    }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/storage.ts",
      "content": "import { createStore, del, get, set } from \"idb-keyval\"\nimport type { Storage } from \"@/registry/batua/batua/type\"\n\nexport const idb = (): Storage => {\n    const store =\n        typeof indexedDB !== \"undefined\"\n            ? createStore(\"batua\", \"store\")\n            : undefined\n    return {\n        async getItem(name) {\n            const value = await get(name, store)\n            if (value === null) return null\n            return value\n        },\n        async removeItem(name) {\n            await del(name, store)\n        },\n        async setItem(name, value) {\n            await set(name, value, store)\n        }\n    }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/type.ts",
      "content": "import type { Chain } from \"viem/chains\"\nimport type { Config } from \"@/registry/batua/batua/index\"\nimport type { Mutate, StoreApi } from \"zustand/vanilla\"\nimport type { Address, RpcRequest, RpcResponse } from \"ox\"\nimport type * as Rpc from \"@/registry/batua/batua/typebox/rpc\"\nimport type { Hex } from \"ox\"\nimport type { Client, MaybePromise, OneOf, WalletCapabilities } from \"viem\"\nimport type { GetCallsStatusReturnType } from \"viem/experimental\"\n\nexport type Storage = {\n    getItem: <value>(name: string) => MaybePromise<value | null>\n    removeItem: (name: string) => MaybePromise<void>\n    setItem: (name: string, value: unknown) => MaybePromise<void>\n}\n\nexport type Call = {\n    to: Address.Address\n    value?: bigint | undefined\n    data?: Hex.Hex | undefined\n}\n\nexport type Implementation = {\n    actions: {\n        loadAccounts: (parameters: {\n            client: Client\n            config: Config\n            request: Rpc.parseRequest.ReturnType\n            store: Store\n        }) => Promise<{ accounts: readonly Account[] }>\n\n        sendCalls: (parameters: {\n            calls: readonly Call[]\n            account: Account\n            client: Client\n            config: Config\n            capabilities?: WalletCapabilities | undefined\n            request: Rpc.parseRequest.ReturnType\n            store: Store\n        }) => Promise<Hex.Hex>\n\n        getCallsStatus: (parameters: {\n            client: Client\n            config: Config\n            request: Rpc.parseRequest.ReturnType\n            store: Store\n            userOperationHash: Hex.Hex\n            timeout?: number\n        }) => Promise<GetCallsStatusReturnType>\n    }\n    setup: (_: { internal: Internal }) => () => void\n}\n\nexport type Compute<type> = { [key in keyof type]: type[key] } & unknown\nexport type Undefined<type> = {\n    [key in keyof type]?: undefined\n}\n\n// biome-ignore lint/complexity/noBannedTypes: optional properties\nexport type BaseKey<type extends string, properties = {}> = Compute<\n    {\n        type: type\n    } & OneOf<\n        | ({\n              canSign: true\n          } & properties)\n        | ({\n              canSign: false\n          } & Undefined<properties>)\n    >\n>\n\nexport type WebAuthnKey = BaseKey<\n    \"webauthn-p256\",\n    {\n        credential: {\n            id: string\n            publicKey: Hex.Hex\n        }\n        rpId: string | undefined\n    }\n>\n\nexport type Key = OneOf<WebAuthnKey>\n\nexport type Account = {\n    address: Address.Address\n    key?: Key\n    type: \"smartAccount\"\n}\n\nexport type QueuedRequest<result = unknown> = {\n    request: RpcRequest.RpcRequest\n} & OneOf<\n    | {\n          status: \"pending\"\n      }\n    | {\n          result: result\n          status: \"success\"\n      }\n    | {\n          error: RpcResponse.ErrorObject\n          status: \"error\"\n      }\n>\n\nexport type State<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = {\n    accounts: readonly Account[]\n    chain: chains[number]\n    requestQueue: readonly QueuedRequest[]\n}\n\nexport type Store<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = Mutate<\n    StoreApi<State<chains>>,\n    [[\"zustand/subscribeWithSelector\", never], [\"zustand/persist\", any]]\n>\n\nexport type Renderer = {\n    setup: (parameters: { internal: Internal }) => {\n        close: () => void\n        destroy: () => void\n        open: () => void\n        syncRequests: (requests: readonly QueuedRequest[]) => Promise<void>\n    }\n}\n\nexport type Internal<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = {\n    config: Config<chains>\n    id: string\n    getImplementation: () => Implementation\n    setImplementation: (i: Implementation) => void\n    store: Store<chains>\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/implementations/local.ts",
      "content": "import { Hex, Provider, RpcRequest } from \"ox\"\nimport type {\n    Implementation,\n    Internal,\n    Store\n} from \"@/registry/batua/batua/type\"\n\nimport ReactDOM from \"react-dom/client\"\nimport React from \"react\"\nimport { Main } from \"@/registry/batua/batua/components/Main\"\nimport { getBundlerClient } from \"@/registry/batua/batua/helpers/getBundlerClient\"\n\nexport const local = (): Implementation => {\n    const requestStore = RpcRequest.createStore()\n\n    function getProvider(store: Store) {\n        return Provider.from({\n            async request(r) {\n                const request = requestStore.prepare(r as any)\n\n                // When we receive a request, we need to add it to the queue.\n                store.setState((x) => ({\n                    ...x,\n                    requestQueue: [\n                        ...x.requestQueue,\n                        {\n                            request,\n                            status: \"pending\"\n                        }\n                    ]\n                }))\n\n                // We need to wait for the request to be resolved.\n                return new Promise((resolve, reject) => {\n                    const unsubscribe = store.subscribe(\n                        (x) => x.requestQueue,\n                        (requestQueue) => {\n                            // If the queue is empty, reject the request as it will\n                            // never be resolved.\n                            if (requestQueue.length === 0) {\n                                unsubscribe()\n                                reject(new Provider.UserRejectedRequestError())\n                            }\n\n                            // Find the request in the queue based off its JSON-RPC identifier.\n                            const queued = requestQueue.find(\n                                (x) => x.request.id === request.id\n                            )\n                            if (!queued) return\n                            if (\n                                queued.status !== \"success\" &&\n                                queued.status !== \"error\"\n                            )\n                                return\n\n                            // We have a response, we can unsubscribe from the store.\n                            unsubscribe()\n\n                            // If the request was successful, resolve with the result.\n                            if (queued.status === \"success\")\n                                resolve(queued.result as any)\n                            // Otherwise, reject with EIP-1193 Provider error.\n                            else reject(Provider.parseError(queued.error))\n\n                            // Remove the request from the queue.\n                            store.setState((x) => ({\n                                ...x,\n                                requestQueue: x.requestQueue.filter(\n                                    (x) => x.request.id !== request.id\n                                )\n                            }))\n                        }\n                    )\n                })\n            }\n        })\n    }\n\n    let internal: Internal\n\n    return {\n        actions: {\n            loadAccounts: async ({ request, store }) => {\n                const provider = getProvider(store)\n\n                const accounts = await (async () => {\n                    if (request.method === \"eth_requestAccounts\") {\n                        const address = await provider.request({\n                            method: \"eth_requestAccounts\"\n                        })\n                        return address.map(\n                            (address) =>\n                                ({\n                                    address,\n                                    type: \"smartAccount\"\n                                }) as const\n                        )\n                    }\n                    throw new Error(\n                        `Cannot load accounts for method: ${request.method}`\n                    )\n                })()\n                return {\n                    accounts\n                }\n            },\n            getCallsStatus: async ({ userOperationHash, timeout }) => {\n                const bundlerClient = getBundlerClient({\n                    internal\n                })\n\n                try {\n                    const receipt =\n                        await bundlerClient.waitForUserOperationReceipt({\n                            hash: userOperationHash,\n                            timeout: timeout ?? 1_000 // 1 second\n                        })\n                    return {\n                        status: \"CONFIRMED\",\n                        receipts: [\n                            {\n                                status: receipt.receipt.status,\n                                logs: receipt.receipt.logs,\n                                blockHash: receipt.receipt.blockHash,\n                                blockNumber: receipt.receipt.blockNumber,\n                                gasUsed: receipt.receipt.gasUsed,\n                                transactionHash: receipt.receipt.transactionHash\n                            }\n                        ]\n                    }\n                } catch (e) {\n                    return {\n                        status: \"PENDING\"\n                    }\n                }\n            },\n            sendCalls: async ({ account, store, calls, capabilities }) => {\n                const provider = getProvider(store)\n                return provider.request({\n                    method: \"wallet_sendCalls\",\n                    params: [\n                        {\n                            version: \"1.0\",\n                            from: account.address,\n                            chainId: Hex.fromNumber(store.getState().chain.id),\n                            capabilities,\n                            calls: calls.map((call) => ({\n                                to: call.to,\n                                value: call.value\n                                    ? Hex.fromNumber(call.value)\n                                    : undefined,\n                                data: call.data\n                            }))\n                        }\n                    ]\n                }) as Promise<Hex.Hex>\n            }\n        },\n        setup: ({ internal: internal_ }) => {\n            internal = internal_\n            if (typeof document === \"undefined\") return () => {}\n            const root = document.createElement(\"div\")\n            root.id = internal.id\n            document.body.appendChild(root)\n            ReactDOM.createRoot(root).render(\n                React.createElement(Main, {\n                    internal\n                })\n            )\n\n            return () => {\n                ReactDOM.createRoot(root).unmount()\n                document.body.removeChild(root)\n            }\n        }\n    }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/helpers/getBundlerClient.ts",
      "content": "import type { Chain, Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/batua/type\"\nimport {\n    type BundlerClient,\n    createBundlerClient\n} from \"viem/account-abstraction\"\n\nconst clientCache = new Map<string, BundlerClient<Transport, Chain>>()\n\nexport const getBundlerClient = ({\n    internal,\n    chainId\n}: { internal: Internal; chainId?: number | undefined }): BundlerClient<\n    Transport,\n    Chain\n> => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n    const client = createBundlerClient({\n        chain,\n        transport: transport.bundler,\n        pollingInterval: 1_000\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/helpers/getClient.ts",
      "content": "import { createClient, type Chain, type Client, type Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/batua/type\"\n\nconst clientCache = new Map<string, Client<Transport, Chain>>()\n\nexport const getClient = ({\n    internal,\n    chainId\n}: { internal: Internal; chainId: number | undefined }): Client<\n    Transport,\n    Chain\n> => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n    const client = createClient({\n        chain,\n        transport: transport.rpc,\n        pollingInterval: 1_000\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/helpers/getPaymasterClient.ts",
      "content": "import type { Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/batua/type\"\nimport {\n    createPaymasterClient,\n    type PaymasterClient\n} from \"viem/account-abstraction\"\n\nconst clientCache = new Map<string, PaymasterClient<Transport>>()\n\nexport const getPaymasterClient = ({\n    internal,\n    chainId\n}: {\n    internal: Internal\n    chainId: number | undefined\n}): PaymasterClient<Transport> | null => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n    if (!transport.paymaster) {\n        return null\n    }\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n    const client = createPaymasterClient({\n        transport: transport.paymaster,\n        pollingInterval: 1_000\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/helpers/getSmartAccountClient.ts",
      "content": "import { http, type WalletCapabilities, type Chain, type Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/batua/type\"\nimport {\n    createPaymasterClient,\n    type PaymasterClient,\n    type SmartAccount\n} from \"viem/account-abstraction\"\nimport type { KernelSmartAccountImplementation } from \"permissionless/accounts\"\nimport {\n    createSmartAccountClient,\n    type SmartAccountClient\n} from \"permissionless\"\nimport { createPimlicoClient } from \"permissionless/clients/pimlico\"\nimport { getPaymasterClient } from \"@/registry/batua/batua/helpers/getPaymasterClient\"\n\nconst clientCache = new Map<\n    string,\n    SmartAccountClient<\n        Transport,\n        Chain,\n        SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n    >\n>()\n\nexport const getSmartAccountClient = ({\n    account,\n    internal,\n    chainId,\n    capabilities\n}: {\n    account: SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n    internal: Internal\n    chainId: number | undefined\n    capabilities: WalletCapabilities | undefined\n}): SmartAccountClient<\n    Transport,\n    Chain,\n    SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n> => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n\n    const pimlicoClient = createPimlicoClient({\n        chain,\n        transport: transport.bundler\n    })\n\n    let paymaster: PaymasterClient | undefined\n\n    if (capabilities?.paymasterService?.url) {\n        paymaster = createPaymasterClient({\n            transport: http(capabilities.paymasterService.url)\n        })\n    }\n\n    if (!paymaster) {\n        paymaster =\n            getPaymasterClient({\n                internal,\n                chainId: internal.store.getState().chain.id\n            }) ?? undefined\n    }\n\n    const client = createSmartAccountClient({\n        chain,\n        bundlerTransport: transport.bundler,\n        account,\n        paymaster,\n        userOperation: {\n            estimateFeesPerGas: async () =>\n                (await pimlicoClient.getUserOperationGasPrice()).fast\n        }\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/capabilities.ts",
      "content": "import * as Permissions from \"@/registry/batua/batua/typebox/permissions\"\nimport * as Primitive from \"@/registry/batua/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/batua/typebox/schema\"\n\nexport namespace createAccount {\n    export const Request = Type.Union([\n        Type.Boolean(),\n        Type.Object({\n            chainId: Schema.Optional(Primitive.TypeboxNumber),\n            label: Schema.Optional(Type.String())\n        })\n    ])\n    export type Request = Schema.StaticDecode<typeof Request>\n}\n\nexport namespace grantPermissions {\n    export const Request = Permissions.Request\n    export type Request = Schema.StaticDecode<typeof Request>\n}\n\nexport namespace permissions {\n    export const Request = Type.Object({\n        id: Schema.Optional(Primitive.Hex)\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(Permissions.Permissions)\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/key.ts",
      "content": "import * as Primitive from \"@/registry/batua/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/batua/typebox/schema\"\n\nexport const Base = Type.Object({\n    /** The expiry of the key. */\n    expiry: Primitive.TypeboxNumber,\n    /** The hash of the key. */\n    hash: Primitive.Hex,\n    /** Public key. */\n    publicKey: Primitive.Hex,\n    /** Role. */\n    role: Type.Union([Type.Literal(\"admin\"), Type.Literal(\"session\")]),\n    /** Key type. */\n    type: Type.Union([\n        Type.Literal(\"address\"),\n        Type.Literal(\"p256\"),\n        Type.Literal(\"secp256k1\"),\n        Type.Literal(\"webauthn-p256\")\n    ])\n})\nexport type Base = Schema.StaticDecode<typeof Base>\n\nexport const CallPermissions = Type.Array(\n    Type.Union([\n        Type.Object({\n            signature: Type.String(),\n            to: Primitive.Address\n        }),\n        Type.Object({\n            signature: Type.String(),\n            to: Schema.Optional(Type.Undefined())\n        }),\n        Type.Object({\n            signature: Schema.Optional(Type.Undefined()),\n            to: Primitive.Address\n        })\n    ]),\n    { minItems: 1 }\n)\nexport type CallPermissions = Schema.StaticDecode<typeof CallPermissions>\n\nexport const SignatureVerificationPermission = Type.Object({\n    addresses: Type.Array(Primitive.Address)\n})\nexport type SignatureVerificationPermission = Schema.StaticDecode<\n    typeof SignatureVerificationPermission\n>\n\nexport const SpendPermissions = Type.Array(\n    Type.Object({\n        limit: Primitive.TypeboxBigInt,\n        period: Type.Union([\n            Type.Literal(\"minute\"),\n            Type.Literal(\"hour\"),\n            Type.Literal(\"day\"),\n            Type.Literal(\"week\"),\n            Type.Literal(\"month\"),\n            Type.Literal(\"year\")\n        ]),\n        token: Schema.Optional(Primitive.Address)\n    })\n)\nexport type SpendPermissions = Schema.StaticDecode<typeof SpendPermissions>\n\nexport const Permissions = Type.Object({\n    calls: Schema.Optional(CallPermissions),\n    signatureVerification: Schema.Optional(SignatureVerificationPermission),\n    spend: Schema.Optional(SpendPermissions)\n})\nexport type Permissions = Schema.StaticDecode<typeof Permissions>\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/permissions.ts",
      "content": "import * as Key from \"@/registry/batua/batua/typebox/key\"\nimport * as Primitive from \"@/registry/batua/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/batua/typebox/schema\"\n\nexport const Permissions = Type.Object({\n    address: Primitive.Address,\n    chainId: Schema.Optional(Primitive.TypeboxNumber),\n    expiry: Type.Number(),\n    id: Primitive.Hex,\n    key: Type.Pick(Key.Base, [\"publicKey\", \"type\"]),\n    permissions: Type.Object({\n        calls: Key.CallPermissions,\n        signatureVerification: Schema.Optional(\n            Key.SignatureVerificationPermission\n        ),\n        spend: Schema.Optional(Key.SpendPermissions)\n    })\n})\nexport type Permissions = Schema.StaticDecode<typeof Permissions>\n\nexport const Request = Type.Object({\n    address: Schema.Optional(Primitive.Address),\n    chainId: Schema.Optional(Primitive.TypeboxNumber),\n    expiry: Type.Number({ minimum: 1 }),\n    key: Schema.Optional(Permissions.properties.key),\n    permissions: Permissions.properties.permissions\n})\nexport type Request = Schema.StaticDecode<typeof Request>\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/primitive.ts",
      "content": "import * as Hex_ox from \"ox/Hex\"\n\nimport { Type } from \"@/registry/batua/batua/typebox/schema\"\n\nexport const Address = Type.TemplateLiteral(\"0x${string}\")\nexport const Hex = Type.TemplateLiteral(\"0x${string}\")\nexport const TypeboxNumber = Type.Transform(Hex)\n    .Decode((value) => Hex_ox.toNumber(value))\n    .Encode((value) => Hex_ox.fromNumber(value))\nexport const TypeboxBigInt = Type.Transform(Hex)\n    .Decode((value) => Hex_ox.toBigInt(value))\n    .Encode((value) => Hex_ox.fromNumber(value))\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/request.ts",
      "content": "import * as C from \"@/registry/batua/batua/typebox/capabilities\"\nimport * as Permissions from \"@/registry/batua/batua/typebox/permissions\"\nimport * as Primitive from \"@/registry/batua/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/batua/typebox/schema\"\n\nexport namespace eth_accounts {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_accounts\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(Primitive.Address)\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_chainId {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_chainId\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_requestAccounts {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_requestAccounts\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(Primitive.Address)\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_sendTransaction {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_sendTransaction\"),\n        params: Type.Tuple([\n            Type.Object({\n                chainId: Schema.Optional(Primitive.TypeboxNumber),\n                data: Schema.Optional(Primitive.Hex),\n                from: Primitive.Address,\n                to: Primitive.Address,\n                value: Schema.Optional(Primitive.TypeboxBigInt)\n            })\n        ])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_signTypedData_v4 {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_signTypedData_v4\"),\n        params: Type.Tuple([Primitive.Address, Type.String()])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_createAccount {\n    export const Parameters = Type.Intersect([\n        Type.Object({\n            chainId: Schema.Optional(Primitive.TypeboxNumber),\n            label: Schema.Optional(Type.String())\n        })\n    ])\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_createAccount\"),\n        params: Schema.Optional(Type.Tuple([Parameters]))\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const ResponseCapabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Response)\n    })\n    export type ResponseCapabilities = Schema.StaticDecode<\n        typeof ResponseCapabilities\n    >\n\n    export const Response = Type.Object({\n        address: Primitive.Address,\n        capabilities: Schema.Optional(ResponseCapabilities)\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_grantPermissions {\n    export const Parameters = Permissions.Request\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_grantPermissions\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Permissions.Permissions\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_permissions {\n    export const Parameters = Type.Object({\n        address: Schema.Optional(Primitive.Address)\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_permissions\"),\n        params: Schema.Optional(Type.Tuple([Parameters]))\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = C.permissions.Response\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_prepareUpgradeAccount {\n    export const Capabilities = Type.Object({\n        grantPermissions: Schema.Optional(C.grantPermissions.Request)\n    })\n    export type Capabilities = Schema.StaticDecode<typeof Capabilities>\n\n    export const Parameters = Type.Object({\n        address: Primitive.Address,\n        chainId: Schema.Optional(Primitive.TypeboxNumber),\n        capabilities: Schema.Optional(Capabilities),\n        label: Schema.Optional(Type.String())\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_prepareUpgradeAccount\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Object({\n        context: Type.Unknown(),\n        signPayloads: Type.Array(Primitive.Hex)\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_revokePermissions {\n    export const Parameters = Type.Object({\n        address: Schema.Optional(Primitive.Address),\n        id: Primitive.Hex\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_revokePermissions\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = undefined\n}\n\nexport namespace experimental_upgradeAccount {\n    export const Parameters = Type.Object({\n        context: Type.Unknown(),\n        signatures: Type.Array(Primitive.Hex)\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_upgradeAccount\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const ResponseCapabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Response)\n    })\n    export type ResponseCapabilities = Schema.StaticDecode<\n        typeof ResponseCapabilities\n    >\n\n    export const Response = Type.Object({\n        address: Primitive.Address,\n        capabilities: Schema.Optional(ResponseCapabilities)\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace personal_sign {\n    export const Request = Type.Object({\n        method: Type.Literal(\"personal_sign\"),\n        params: Type.Tuple([Primitive.Hex, Primitive.Address])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n}\n\nexport namespace batua_ping {\n    export const Request = Type.Object({\n        method: Type.Literal(\"batua_ping\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Literal(\"pong\")\n}\n\nexport namespace wallet_connect {\n    export const Capabilities = Type.Object({\n        createAccount: Schema.Optional(C.createAccount.Request),\n        grantPermissions: Schema.Optional(C.grantPermissions.Request),\n        selectAccount: Schema.Optional(Type.Boolean())\n    })\n    export type Capabilities = Schema.StaticDecode<typeof Capabilities>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_connect\"),\n        params: Schema.Optional(\n            Type.Tuple([\n                Type.Object({\n                    capabilities: Schema.Optional(Capabilities)\n                })\n            ])\n        )\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const ResponseCapabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Response)\n    })\n    export type ResponseCapabilities = Schema.StaticDecode<\n        typeof ResponseCapabilities\n    >\n\n    export const Response = Type.Object({\n        accounts: Type.Array(\n            Type.Object({\n                address: Primitive.Address,\n                capabilities: Schema.Optional(ResponseCapabilities)\n            })\n        )\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_disconnect {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_disconnect\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = undefined\n}\n\nexport namespace wallet_getCallsStatus {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_getCallsStatus\"),\n        params: Type.Tuple([Primitive.Hex])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Object({\n        receipts: Schema.Optional(\n            Type.Array(\n                Type.Object({\n                    logs: Type.Array(\n                        Type.Object({\n                            address: Primitive.Address,\n                            data: Primitive.Hex,\n                            topics: Type.Array(Primitive.Hex)\n                        })\n                    ),\n                    status: Primitive.Hex,\n                    blockHash: Primitive.Hex,\n                    blockNumber: Primitive.Hex,\n                    gasUsed: Primitive.Hex,\n                    transactionHash: Primitive.Hex\n                })\n            )\n        ),\n        status: Type.Union([Type.Literal(\"CONFIRMED\"), Type.Literal(\"PENDING\")])\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_getCapabilities {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_getCapabilities\"),\n        params: Type.Union([\n            Type.Tuple([Primitive.Address, Type.Array(Primitive.Hex)]),\n            Type.Tuple([Primitive.Address])\n        ])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Record(\n        Primitive.Hex,\n        Type.Object({\n            atomicBatch: Type.Object({\n                supported: Type.Boolean()\n            }),\n            createAccount: Type.Object({\n                supported: Type.Boolean()\n            }),\n            permissions: Type.Object({\n                supported: Type.Boolean()\n            })\n        })\n    )\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_prepareCalls {\n    export const Capabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Request)\n    })\n    export type Capabilities = Schema.StaticDecode<typeof Capabilities>\n\n    export const Parameters = Type.Object({\n        calls: Type.Array(\n            Type.Object({\n                to: Primitive.Address,\n                data: Schema.Optional(Primitive.Hex),\n                value: Schema.Optional(Primitive.TypeboxBigInt)\n            })\n        ),\n        key: Type.Object({\n            publicKey: Primitive.Hex,\n            type: Type.Union([\n                Type.Literal(\"p256\"),\n                Type.Literal(\"secp256k1\"),\n                Type.Literal(\"webauthn-p256\"),\n                Type.Literal(\"address\")\n            ])\n        }),\n        capabilities: Schema.Optional(Capabilities),\n        chainId: Schema.Optional(Primitive.TypeboxNumber),\n        from: Schema.Optional(Primitive.Address),\n        version: Schema.Optional(Type.String())\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_prepareCalls\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Object({\n        capabilities: Schema.Optional(Type.Record(Type.String(), Type.Any())),\n        chainId: Primitive.Hex,\n        context: Type.Object({\n            account: Type.Object({\n                address: Primitive.Address,\n                type: Type.Literal(\"delegated\")\n            }),\n            calls: Parameters.properties.calls,\n            nonce: Primitive.TypeboxBigInt\n        }),\n        digest: Primitive.Hex,\n        key: Parameters.properties.key\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_sendCalls {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_sendCalls\"),\n        params: Type.Tuple([Type.Omit(wallet_prepareCalls.Parameters, [\"key\"])])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_sendPreparedCalls {\n    export const Parameters = Type.Object({\n        capabilities: wallet_prepareCalls.Response.properties.capabilities,\n        chainId: Primitive.Hex,\n        context: wallet_prepareCalls.Response.properties.context,\n        key: wallet_prepareCalls.Response.properties.key,\n        signature: Primitive.Hex\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_sendPreparedCalls\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(\n        Type.Object({\n            id: Type.String(),\n            capabilities: Schema.Optional(\n                Type.Record(Type.String(), Type.Any())\n            )\n        })\n    )\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/rpc.ts",
      "content": "import * as Json from \"ox/Json\"\nimport * as RpcResponse from \"ox/RpcResponse\"\n\nimport type { Union } from \"@sinclair/typebox/type\"\nimport * as RpcRequest from \"@/registry/batua/batua/typebox/request\"\nimport {\n    type StaticDecode,\n    type StaticEncode,\n    Type,\n    Value\n} from \"@/registry/batua/batua/typebox/schema\"\n\nexport * from \"@/registry/batua/batua/typebox/request\"\n\nexport const Request = Type.Union([\n    RpcRequest.eth_accounts.Request,\n    RpcRequest.eth_chainId.Request,\n    RpcRequest.eth_requestAccounts.Request,\n    RpcRequest.eth_sendTransaction.Request,\n    RpcRequest.eth_signTypedData_v4.Request,\n    RpcRequest.experimental_permissions.Request,\n    RpcRequest.experimental_createAccount.Request,\n    RpcRequest.experimental_grantPermissions.Request,\n    RpcRequest.experimental_prepareUpgradeAccount.Request,\n    RpcRequest.experimental_revokePermissions.Request,\n    RpcRequest.experimental_upgradeAccount.Request,\n    RpcRequest.personal_sign.Request,\n    RpcRequest.batua_ping.Request,\n    RpcRequest.wallet_connect.Request,\n    RpcRequest.wallet_disconnect.Request,\n    RpcRequest.wallet_getCallsStatus.Request,\n    RpcRequest.wallet_getCapabilities.Request,\n    RpcRequest.wallet_prepareCalls.Request,\n    RpcRequest.wallet_sendCalls.Request,\n    RpcRequest.wallet_sendPreparedCalls.Request\n])\n\nexport function parseRequest(request: unknown): parseRequest.ReturnType {\n    const raw = Value.Convert(Request, request)\n\n    const method = RpcRequest[(raw as any).method as keyof typeof RpcRequest]\n    if (method) {\n        const error = Value.Errors(method.Request, raw).First()\n        const message = [\n            error?.message,\n            \"\",\n            `Path: ${error?.path.slice(1).replaceAll(\"/\", \".\")}`,\n            error?.value && `Value: ${Json.stringify(error.value)}`\n        ]\n            .filter((x) => typeof x === \"string\")\n            .join(\"\\n\")\n        if (error) throw new RpcResponse.InvalidParamsError({ message })\n    }\n\n    Value.Assert(Request, raw)\n    const _decoded = Value.Decode(Request, raw)\n\n    return {\n        ...raw,\n        _decoded\n    } as never\n}\n\nexport declare namespace parseRequest {\n    export type ReturnType = typeof Request extends Union<infer U>\n        ? {\n              [K in keyof U]: StaticEncode<U[K]> & {\n                  _decoded: StaticDecode<U[K]>\n              }\n          }[number]\n        : never\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/schema.ts",
      "content": "import {\n    Kind,\n    type StaticDecode as StaticDecode_typebox,\n    type StaticEncode as StaticEncode_typebox,\n    type Static as Static_typebox,\n    type TNever,\n    type TOptional,\n    type TSchema,\n    type TUndefined,\n    type TUnion,\n    Type\n} from \"@sinclair/typebox/type\"\nexport { Type } from \"@sinclair/typebox/type\"\nexport { Value, Encode, Decode } from \"@sinclair/typebox/value\"\n\nimport type {\n    DeepReadonly,\n    OneOf as OneOfType\n} from \"@/registry/batua/batua/typebox/types\"\n\nexport function OneOf<schemas extends TSchema[]>(\n    schemas: [...schemas]\n): OneOf.ReturnType<schemas> {\n    return Type.Union(schemas) as never\n}\n\nexport declare namespace OneOf {\n    type OneOfStatic<T extends TSchema[], P extends unknown[]> = {\n        [K in keyof T]: T[K] extends TSchema ? Static_typebox<T[K], P> : never\n    }[number]\n\n    export interface ReturnType<T extends TSchema[] = TSchema[]>\n        extends TSchema {\n        [Kind]: \"Union\"\n        // @ts-expect-error\n        static: OneOfType<OneOfStatic<T, this[\"params\"]>>\n    }\n\n    export type OneOf<T extends TSchema[]> = T extends []\n        ? TNever\n        : T extends [TSchema]\n          ? T[0]\n          : ReturnType<T>\n}\n\nexport function Optional<schema extends TSchema>(\n    schema: schema\n): TOptional<TUnion<[schema, TUndefined]>> {\n    return Type.Optional(schema) as never\n}\n\nexport type StaticDecode<\n    T extends TSchema,\n    P extends unknown[] = []\n> = DeepReadonly<StaticDecode_typebox<T, P>>\n\nexport type StaticEncode<\n    T extends TSchema,\n    P extends unknown[] = []\n> = DeepReadonly<StaticEncode_typebox<T, P>>\n\nexport type Static<T extends TSchema, P extends unknown[] = []> = DeepReadonly<\n    Static_typebox<T, P>\n>\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/batua/batua/typebox/types.ts",
      "content": "/** Combines members of an intersection into a readable type. */\n// https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg\nexport type Compute<type> = { [key in keyof type]: type[key] } & unknown\n\ndeclare const symbol: unique symbol\n\n/**\n * Creates a branded type of `T` with the brand `U`.\n *\n * @example\n * ```ts\n * type Result = Branded<string, 'foo'>\n * //   ^? type Result = string & { [symbol]: 'foo' }\n * ```\n */\nexport type Branded<T, U> = T & { [symbol]: U }\n\n/**\n * Filters out all members of `T` that are not `P`\n *\n * @example\n * ```ts\n * type Result = Filter<['a', 'b', 'c'], 'b'>\n * //   ^? type Result = ['a', 'c']\n * ```\n *\n * @internal\n */\nexport type Filter<\n    T extends readonly unknown[],\n    P,\n    Acc extends readonly unknown[] = []\n> = T extends readonly [infer F, ...infer Rest extends readonly unknown[]]\n    ? [F] extends [P]\n        ? Filter<Rest, P, [...Acc, F]>\n        : Filter<Rest, P, Acc>\n    : readonly [...Acc]\n\n/**\n * Checks if `T` can be narrowed further than `U`\n *\n * @example\n * ```ts\n * type Result = IsNarrowable<'foo', string>\n * //   ^? true\n * ```\n */\nexport type IsNarrowable<T, U> = IsNever<\n    (T extends U ? true : false) & (U extends T ? false : true)\n> extends true\n    ? false\n    : true\n\n/**\n * Checks if `T` is `never`\n *\n * @example\n * ```ts\n * type Result = IsNever<never>\n * //   ^? type Result = true\n * ```\n */\nexport type IsNever<T> = [T] extends [never] ? true : false\n\n/**\n * Removes `readonly` from all properties of an object.\n *\n * @internal\n */\nexport type Mutable<type extends object> = {\n    -readonly [key in keyof type]: type[key]\n}\n\n/**\n * Evaluates boolean \"or\" condition for `T` properties.\n *\n * * @example\n * ```ts\n * type Result = Or<[false, true, false]>\n * //   ^? type Result = true\n * ```\n *\n * @example\n * ```ts\n * type Result = Or<[false, false, false]>\n * //   ^? type Result = false\n * ```\n *\n * @internal\n */\nexport type Or<T extends readonly unknown[]> = T extends readonly [\n    infer Head,\n    ...infer Tail\n]\n    ? Head extends true\n        ? true\n        : Or<Tail>\n    : false\n\n/**\n * Checks if `T` is `undefined`\n *\n * @example\n * ```ts\n * type Result = IsUndefined<undefined>\n * //   ^? type Result = true\n * ```\n *\n * @internal\n */\nexport type IsUndefined<T> = [undefined] extends [T] ? true : false\n\n/**\n * Checks if type `T` is the `unknown` type.\n *\n * @internal\n */\nexport type IsUnknown<T> = unknown extends T\n    ? [T] extends [null]\n        ? false\n        : true\n    : false\n\n/** @internal */\nexport type MaybePromise<T> = T | Promise<T>\n\n/**\n * Makes attributes on the type T required if required is true.\n *\n * @example\n * ```ts\n * MaybeRequired<{ a: string, b?: number }, true>\n * // { a: string, b: number }\n *\n * MaybeRequired<{ a: string, b?: number }, false>\n * // { a: string, b?: number }\n * ```\n *\n * @internal\n */\nexport type MaybeRequired<T, required extends boolean> = required extends true\n    ? ExactRequired<T>\n    : T\n\n/**\n * Assigns the properties of U onto T.\n *\n * @example\n * ```ts\n * Assign<{ a: string, b: number }, { a: undefined, c: boolean }>\n * // { a: undefined, b: number, c: boolean }\n * ```\n *\n * @internal\n */\nexport type Assign<T, U> = Assign_inner<T, U> & U\n\n/** @internal */\nexport type Assign_inner<T, U> = {\n    [K in keyof T as K extends keyof U\n        ? U[K] extends void\n            ? never\n            : K\n        : K]: K extends keyof U ? U[K] : T[K]\n}\n\n/**\n * Constructs a type by excluding `undefined` from `T`.\n *\n * @example\n * ```ts\n * NoUndefined<string | undefined>\n * // string\n * ```\n *\n * @internal\n */\nexport type NoUndefined<T> = T extends undefined ? never : T\n\n/**\n * Strict version of built-in Omit type\n *\n * @internal\n */\nexport type Omit<type, keys extends keyof type> = Pick<\n    type,\n    Exclude<keyof type, keys>\n>\n\n/**\n * Creates a type that is a partial of T, but with the required keys K.\n *\n * @example\n * ```ts\n * PartialBy<{ a: string, b: number }, 'a'>\n * // { a?: string, b: number }\n * ```\n *\n * @internal\n */\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> &\n    ExactPartial<Pick<T, K>>\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\n/**\n * Creates a type that is T with the required keys K.\n *\n * @example\n * ```ts\n * RequiredBy<{ a?: string, b: number }, 'a'>\n * // { a: string, b: number }\n * ```\n *\n * @internal\n */\nexport type RequiredBy<T, K extends keyof T> = Omit<T, K> &\n    ExactRequired<Pick<T, K>>\n\n/**\n * Returns truthy if `array` contains `value`.\n *\n * @example\n * ```ts\n * Some<[1, 2, 3], 2>\n * // true\n * ```\n *\n * @internal\n */\nexport type Some<\n    array extends readonly unknown[],\n    value\n> = array extends readonly [value, ...unknown[]]\n    ? true\n    : array extends readonly [unknown, ...infer rest]\n      ? Some<rest, value>\n      : false\n\n/**\n * Prints custom error message\n *\n * @param messages - Error message\n * @returns Custom error message\n *\n * @example\n * ```ts\n * type Result = TypeErrorMessage<'Custom error message'>\n * //   ^? type Result = ['Error: Custom error message']\n * ```\n */\nexport type TypeErrorMessage<messages extends string | string[]> =\n    messages extends string\n        ? [\n              // Surrounding with array to prevent `messages` from being widened to `string`\n              `Error: ${messages}`\n          ]\n        : {\n              [key in keyof messages]: messages[key] extends infer message extends\n                  string\n                  ? `Error: ${message}`\n                  : never\n          }\n\n/** @internal */\nexport type UnionToTuple<\n    union,\n    ///\n    last = LastInUnion<union>\n> = [union] extends [never] ? [] : [...UnionToTuple<Exclude<union, last>>, last]\n\n/** @internal */\nexport type LastInUnion<U> = UnionToIntersection<\n    U extends unknown ? (x: U) => 0 : never\n> extends (x: infer l) => 0\n    ? l\n    : never\n\n/** @internal */\nexport type UnionToIntersection<union> = (\n    union extends unknown\n        ? (arg: union) => 0\n        : never\n) extends (arg: infer i) => 0\n    ? i\n    : never\n\n/** @internal */\nexport type IsUnion<\n    union,\n    ///\n    union2 = union\n> = union extends union2 ? ([union2] extends [union] ? false : true) : never\n\n/** @internal */\nexport type MaybePartial<\n    type,\n    enabled extends boolean | undefined\n> = enabled extends true ? Compute<ExactPartial<type>> : type\n\nexport type ExactPartial<type> = {\n    [key in keyof type]?: type[key] | undefined\n}\n\n/** @internal */\nexport type ExactRequired<type> = {\n    [key in keyof type]-?: Exclude<type[key], undefined>\n}\n\nexport type OneOf<\n    union extends object,\n    fallback extends object | undefined = undefined,\n    ///\n    keys extends KeyofUnion<union> = KeyofUnion<union>\n> = union extends infer item\n    ? Compute<\n          item & {\n              [key in Exclude<keys, keyof item>]?: fallback extends object\n                  ? key extends keyof fallback\n                      ? fallback[key]\n                      : undefined\n                  : undefined\n          }\n      >\n    : never\n\n/** @internal */\nexport type KeyofUnion<type> = type extends type ? keyof type : never\n\n/** @internal */\nexport type Undefined<type> = {\n    [key in keyof type]?: undefined\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Loose types\n\n/**\n * Loose version of {@link Omit}\n * @internal\n */\nexport type LooseOmit<type, keys extends string> = Pick<\n    type,\n    Exclude<keyof type, keys>\n>\n\n///////////////////////////////////////////////////////////////////////////\n// Union types\n\n/** @internal */\nexport type UnionCompute<type> = type extends object ? Compute<type> : type\n\n/** @internal */\nexport type UnionLooseOmit<type, keys extends string> = type extends any\n    ? LooseOmit<type, keys>\n    : never\n\n/**\n * Construct a type with the properties of union type T except for those in type K.\n * @example\n * ```ts\n * type Result = UnionOmit<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>\n * // { b: number } | { b: undefined, c: number }\n * ```\n *\n * @internal\n */\nexport type UnionOmit<type, keys extends keyof type> = type extends any\n    ? Omit<type, keys>\n    : never\n\n/**\n * Construct a type with the properties of union type T except for those in type K.\n * @example\n * ```ts\n * type Result = UnionOmit<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>\n * // { b: number } | { b: undefined, c: number }\n * ```\n *\n * @internal\n */\nexport type UnionPick<type, keys extends keyof type> = type extends any\n    ? Pick<type, keys>\n    : never\n\n/**\n * Creates a type that is a partial of T, but with the required keys K.\n *\n * @example\n * ```ts\n * PartialBy<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>\n * // { a?: string, b: number } | { a?: string, b: undefined, c: number }\n * ```\n *\n * @internal\n */\nexport type UnionPartialBy<T, K extends keyof T> = T extends any\n    ? PartialBy<T, K>\n    : never\n\n/**\n * Creates a type that is T with the required keys K.\n *\n * @example\n * ```ts\n * RequiredBy<{ a?: string, b: number } | { a?: string, c?: number }, 'a'>\n * // { a: string, b: number } | { a: string, c?: number }\n * ```\n *\n * @internal\n */\nexport type UnionRequiredBy<T, K extends keyof T> = T extends any\n    ? RequiredBy<T, K>\n    : never\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\ntype Builtin = Primitive | Date | Error | RegExp\n\nexport type DeepReadonly<T> = T extends Builtin\n    ? T\n    : IsUnknown<T> extends true\n      ? T\n      : T extends object\n        ? Readonly<{\n              [K in keyof T]: T[K] extends Primitive ? T[K] : DeepReadonly<T[K]>\n          }>\n        : T extends Array<infer U>\n          ? U extends Primitive\n              ? Readonly<Array<U>>\n              : Readonly<Array<DeepReadonly<U>>>\n          : never\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "wallet",
    "ethereum",
    "account-abstraction"
  ]
}