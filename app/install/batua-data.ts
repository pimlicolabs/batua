// This file is auto-generated during build - do not edit manually
// Generated on: 2025-04-17T14:23:10.727Z

export const batuaData = {
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "batua",
  "type": "registry:block",
  "title": "Batua",
  "description": "A wallet provider for wagmi with support for account abstraction.",
  "dependencies": [
    "viem@^2.27.0",
    "zustand@^5.0.3",
    "ox@^0.6.12",
    "lucide-react@^0.471.1",
    "permissionless@^0.2.42",
    "react@^19.0.0",
    "mipd@^0.0.7",
    "zod@^3.24.1",
    "idb-keyval@^6.2.1",
    "@sinclair/typebox@^0.34.33",
    "react-dom@^19.0.0"
  ],
  "registryDependencies": [
    "accordion",
    "alert",
    "button",
    "dialog",
    "separator",
    "tooltip"
  ],
  "files": [
    {
      "path": "registry/batua/components/batua/Login.tsx",
      "content": "\"use client\"\nimport { WebAuthnP256 } from \"ox\"\nimport type { QueuedRequest, Internal } from \"@/registry/batua/lib/batua/type\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n    Dialog,\n    DialogContent,\n    DialogDescription,\n    DialogHeader,\n    DialogTitle,\n    DialogFooter\n} from \"@/components/ui/dialog\"\nimport {\n    AlertCircle,\n    LogIn,\n    KeyRound,\n    Fingerprint,\n    Loader2,\n    HelpCircle\n} from \"lucide-react\"\nimport { Provider } from \"ox\"\nimport { toKernelSmartAccount } from \"permissionless/accounts\"\nimport { getClient } from \"@/registry/batua/lib/batua/helpers/getClient\"\nimport {\n    createWebAuthnCredential,\n    entryPoint07Address,\n    toWebAuthnAccount\n} from \"viem/account-abstraction\"\nimport { createPasskeyServerClient } from \"permissionless/clients/passkeyServer\"\nimport * as Key from \"@/registry/batua/lib/batua/key\"\nimport { useCallback, useMemo, useState } from \"react\"\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\nimport {\n    Tooltip,\n    TooltipContent,\n    TooltipProvider,\n    TooltipTrigger\n} from \"@/components/ui/tooltip\"\nimport { Errors } from \"ox\"\nimport { BaseError } from \"viem\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n    randomAdjective,\n    randomNoun\n} from \"@/registry/batua/lib/batua/helpers/randomWords\"\n\nexport const Login = ({\n    onComplete,\n    queueRequest,\n    internal,\n    dummy\n}: {\n    onComplete: (args: {\n        queueRequest: QueuedRequest\n    }) => void | Promise<void>\n    queueRequest: QueuedRequest\n    internal: Internal\n    dummy?: boolean\n}) => {\n    const [error, setError] = useState<string | null>(null)\n    const [isLoading, setIsLoading] = useState<\"signin\" | \"signup\" | null>(null)\n\n    const walletName = useMemo(\n        () => internal.config.walletName,\n        [internal.config]\n    )\n\n    const createCredential = useCallback(async () => {\n        if (dummy) {\n            return\n        }\n        try {\n            setIsLoading(\"signup\")\n            const client = getClient({\n                internal,\n                chainId: internal.store.getState().chain.id\n            })\n            const credential = await (async () => {\n                try {\n                    const passkeyServerClient = createPasskeyServerClient({\n                        chain: client.chain,\n                        transport:\n                            internal.config.bundler.transports[client.chain.id]\n                    })\n\n                    const userName = `${randomAdjective()}_${randomNoun()}`\n\n                    const credential = await createWebAuthnCredential(\n                        // Start the registration process\n                        await passkeyServerClient.startRegistration({\n                            context: {\n                                userName\n                            }\n                        })\n                    )\n\n                    // Verify the registration\n                    const verifiedCredential =\n                        await passkeyServerClient.verifyRegistration({\n                            credential,\n                            context: {\n                                userName\n                            }\n                        })\n\n                    if (!verifiedCredential.success) {\n                        throw new Error(\"Failed to verify registration\")\n                    }\n\n                    return {\n                        id: verifiedCredential.id,\n                        publicKey: verifiedCredential.publicKey,\n                        userName\n                    }\n                } catch {\n                    onComplete({\n                        queueRequest: {\n                            request: queueRequest.request,\n                            status: \"error\",\n                            error: new Provider.UserRejectedRequestError()\n                        }\n                    })\n                    return null\n                }\n            })()\n            if (!credential) return\n            const smartAccount = await toKernelSmartAccount({\n                client,\n                version: \"0.3.1\",\n                owners: [toWebAuthnAccount({ credential })],\n                entryPoint: {\n                    address: entryPoint07Address,\n                    version: \"0.7\"\n                }\n            })\n            internal.store.setState((x) => ({\n                ...x,\n                accounts: [\n                    ...x.accounts,\n                    {\n                        address: smartAccount.address,\n                        key: Key.fromWebAuthnP256({\n                            credential: credential,\n                            //todo: use rpId\n                            rpId: undefined\n                        }),\n                        type: \"smartAccount\",\n                        name: credential.userName\n                    }\n                ]\n            }))\n            onComplete({\n                queueRequest: {\n                    request: queueRequest.request,\n                    status: \"success\",\n                    result: [smartAccount.address]\n                }\n            })\n        } catch (error) {\n            console.error(\"Error creating credential:\", error)\n            setError(\"Failed to create passkey. Please try again.\")\n            // triggerShake()\n        } finally {\n            setIsLoading(null)\n        }\n    }, [dummy, internal, onComplete, queueRequest.request])\n\n    const signIn = useCallback(async () => {\n        if (dummy) {\n            return\n        }\n        try {\n            setIsLoading(\"signin\")\n            const client = getClient({\n                internal,\n                chainId: internal.store.getState().chain.id\n            })\n            const passkeyServerClient = createPasskeyServerClient({\n                chain: client.chain,\n                transport: internal.config.bundler.transports[client.chain.id]\n            })\n\n            const challenge = await passkeyServerClient.startAuthentication()\n\n            const signature = await WebAuthnP256.sign(challenge)\n\n            const verifiedCredential =\n                await passkeyServerClient.verifyAuthentication({\n                    ...signature,\n                    uuid: challenge.uuid\n                })\n\n            if (!verifiedCredential.success) {\n                throw new Error(\"Failed to verify authentication\")\n            }\n\n            const credential = {\n                id: verifiedCredential.id,\n                publicKey: verifiedCredential.publicKey\n            }\n\n            const smartAccount = await toKernelSmartAccount({\n                client,\n                version: \"0.3.1\",\n                owners: [toWebAuthnAccount({ credential })],\n                entryPoint: {\n                    address: entryPoint07Address,\n                    version: \"0.7\"\n                }\n            })\n            internal.store.setState((x) => ({\n                ...x,\n                accounts: [\n                    ...x.accounts,\n                    {\n                        address: smartAccount.address,\n                        key: Key.fromWebAuthnP256({\n                            credential: credential,\n                            //todo: use rpId\n                            rpId: undefined\n                        }),\n                        name: verifiedCredential.userName,\n                        type: \"smartAccount\"\n                    }\n                ]\n            }))\n            onComplete({\n                queueRequest: {\n                    request: queueRequest.request,\n                    status: \"success\",\n                    result: [smartAccount.address]\n                }\n            })\n        } catch (error) {\n            const { code, errorMessage } = (() => {\n                if (\n                    error instanceof Error &&\n                    error.message === \"Failed to verify authentication\"\n                ) {\n                    return {\n                        code: \"INVALID_SIGNATURE\",\n                        errorMessage: \"Failed to verify authentication\"\n                    }\n                }\n\n                if (\n                    error instanceof BaseError ||\n                    error instanceof Errors.BaseError\n                ) {\n                    const notAllowedError = error.walk(\n                        (e) =>\n                            e instanceof Error && e.name === \"NotAllowedError\"\n                    )\n\n                    if (notAllowedError) {\n                        return {\n                            code: \"NOT_ALLOWED\",\n                            errorMessage: \"User rejected the request\"\n                        }\n                    }\n\n                    const e = error.walk(\n                        (e) =>\n                            e instanceof BaseError &&\n                            e.name === \"InternalRpcError\"\n                    ) as BaseError | undefined\n\n                    if (e?.details) {\n                        return {\n                            errorMessage:\n                                e.details === \"Passkey not found\"\n                                    ? \"Invalid passkey, please sign up or try again with a different passkey\"\n                                    : \"Failed to sign in, please sign up or try using correct passkey\"\n                        }\n                    }\n                }\n\n                return {\n                    errorMessage:\n                        \"Failed to sign in, please try using correct passkey\"\n                }\n            })()\n\n            if (code === \"NOT_ALLOWED\") {\n                onComplete({\n                    queueRequest: {\n                        request: queueRequest.request,\n                        status: \"error\",\n                        error: new Provider.UserRejectedRequestError()\n                    }\n                })\n                return\n            }\n\n            setError(errorMessage)\n            // triggerShake()\n            return\n        } finally {\n            setIsLoading(null)\n        }\n    }, [dummy, internal, onComplete, queueRequest])\n\n    const onOpenChange = useCallback(\n        (open: boolean) => {\n            if (dummy) {\n                return\n            }\n            if (!open) {\n                onComplete({\n                    queueRequest: {\n                        request: queueRequest.request,\n                        status: \"error\",\n                        error: new Provider.UserRejectedRequestError()\n                    }\n                })\n            }\n        },\n        [dummy, onComplete, queueRequest.request]\n    )\n\n    return (\n        <Dialog open={!!queueRequest} onOpenChange={onOpenChange}>\n            <DialogContent\n                className={\"sm:max-w-[325px] p-0\"}\n                style={{ zIndex: 4294967290 }}\n            >\n                <div className=\"bg-primary/5 p-6 rounded-t-lg\">\n                    <DialogHeader className=\"pb-0\">\n                        <div className=\"flex items-center gap-2\">\n                            <KeyRound className=\"h-5 w-5 text-primary\" />\n                            <DialogTitle>Sign in</DialogTitle>\n                        </div>\n                        <DialogDescription>\n                            Create or access your wallet securely with your\n                            passkey\n                        </DialogDescription>\n                    </DialogHeader>\n                </div>\n\n                <div className=\"p-6 pt-5\">\n                    {error && (\n                        <Alert variant=\"destructive\" className=\"mb-5\">\n                            <AlertCircle className=\"h-4 w-4\" />\n                            <AlertDescription>{error}</AlertDescription>\n                        </Alert>\n                    )}\n\n                    <div className=\"space-y-5\">\n                        <div className=\"space-y-2.5\">\n                            <h3 className=\"text-sm font-medium flex items-center gap-1\">\n                                Already have a {walletName}?\n                                <TooltipProvider>\n                                    <Tooltip>\n                                        <TooltipTrigger asChild>\n                                            <HelpCircle className=\"h-3.5 w-3.5 text-muted-foreground cursor-help\" />\n                                        </TooltipTrigger>\n                                        <TooltipContent\n                                            className=\"max-w-[220px]\"\n                                            style={{ zIndex: 4294967294 }}\n                                        >\n                                            <p>\n                                                {walletName} is an embedded\n                                                smart account that secures your\n                                                account with passkeys.\n                                            </p>\n                                        </TooltipContent>\n                                    </Tooltip>\n                                </TooltipProvider>\n                            </h3>\n                            <Button\n                                className=\"w-full h-11\"\n                                variant=\"outline\"\n                                onClick={signIn}\n                                disabled={isLoading !== null}\n                            >\n                                {isLoading === \"signin\" ? (\n                                    <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                ) : (\n                                    <Fingerprint className=\"h-4 w-4 text-primary\" />\n                                )}\n                                Sign in with passkey\n                            </Button>\n                        </div>\n\n                        <div className=\"relative py-1\">\n                            <div className=\"absolute inset-0 flex items-center\">\n                                <Separator className=\"w-full\" />\n                            </div>\n                            <div className=\"relative flex justify-center text-xs uppercase\">\n                                <span className=\"bg-background px-2 text-muted-foreground\">\n                                    Or\n                                </span>\n                            </div>\n                        </div>\n\n                        <div className=\"space-y-2.5\">\n                            <h3 className=\"text-sm font-medium flex items-center gap-1\">\n                                New to {walletName}?\n                                <TooltipProvider>\n                                    <Tooltip>\n                                        <TooltipTrigger asChild>\n                                            <HelpCircle className=\"h-3.5 w-3.5 text-muted-foreground cursor-help\" />\n                                        </TooltipTrigger>\n                                        <TooltipContent\n                                            className=\"max-w-[220px]\"\n                                            style={{ zIndex: 4294967294 }}\n                                        >\n                                            <p>\n                                                {walletName} is an embedded\n                                                smart account that secures your\n                                                account with passkeys.\n                                            </p>\n                                        </TooltipContent>\n                                    </Tooltip>\n                                </TooltipProvider>\n                            </h3>\n                            <Button\n                                className=\"w-full h-11\"\n                                onClick={() => {\n                                    setError(null)\n                                    createCredential()\n                                }}\n                                disabled={isLoading !== null}\n                            >\n                                {isLoading === \"signup\" ? (\n                                    <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                ) : (\n                                    <LogIn className=\"h-4 w-4\" />\n                                )}\n                                Create new wallet\n                            </Button>\n                        </div>\n                    </div>\n                </div>\n\n                <DialogFooter className=\"bg-muted/20 px-6 py-4 border-t\">\n                    <div className=\"w-full text-xs text-center text-muted-foreground\">\n                        Your credentials are stored securely and never leave\n                        your device\n                    </div>\n                </DialogFooter>\n            </DialogContent>\n        </Dialog>\n    )\n}\n",
      "type": "registry:component",
      "target": "components/batua/Login.tsx"
    },
    {
      "path": "registry/batua/components/batua/Main.tsx",
      "content": "import React from \"react\"\nimport type { QueuedRequest, Internal } from \"@/registry/batua/lib/batua/type\"\nimport { Login } from \"@/registry/batua/components/batua/Login\"\nimport { SendCalls } from \"@/registry/batua/components/batua/SendCalls\"\n\nexport const Main = ({ internal }: { internal: Internal }) => {\n    const [queueRequest, setQueueRequest] =\n        React.useState<QueuedRequest | null>(null)\n\n    React.useEffect(() => {\n        const unsubscribe = internal.store.subscribe(\n            (x) => x.requestQueue,\n            (requestQueue) => {\n                const requests = requestQueue\n                    .map((x) => (x.status === \"pending\" ? x : undefined))\n                    .filter(Boolean) as readonly QueuedRequest[]\n                if (requests.length === 0) return\n                if (requests[0].request.id === queueRequest?.request.id) return\n                setQueueRequest(requests[0])\n            }\n        )\n\n        return () => {\n            unsubscribe()\n        }\n    }, [internal.store, queueRequest])\n\n    const onComplete = ({ queueRequest }: { queueRequest: QueuedRequest }) => {\n        setQueueRequest(null)\n        internal.store.setState((x) => ({\n            ...x,\n            requestQueue: x.requestQueue.map((req) =>\n                req.request.id === queueRequest.request.id ? queueRequest : req\n            )\n        }))\n    }\n\n    if (queueRequest?.request.method === \"eth_requestAccounts\") {\n        return (\n            <Login\n                internal={internal}\n                queueRequest={queueRequest}\n                onComplete={onComplete}\n            />\n        )\n    }\n\n    if (queueRequest?.request.method === \"wallet_sendCalls\") {\n        return (\n            <SendCalls\n                internal={internal}\n                queueRequest={queueRequest}\n                onComplete={onComplete}\n            />\n        )\n    }\n\n    return null\n}\n",
      "type": "registry:component",
      "target": "components/batua/Main.tsx"
    },
    {
      "path": "registry/batua/components/batua/SendCalls.tsx",
      "content": "\"use client\"\nimport {\n    Dialog,\n    DialogContent,\n    DialogDescription,\n    DialogHeader,\n    DialogTitle\n} from \"@/components/ui/dialog\"\nimport type {\n    Account,\n    Internal,\n    QueuedRequest\n} from \"@/registry/batua/lib/batua/type\"\nimport { Provider, RpcRequest } from \"ox\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n    type KernelSmartAccountImplementation,\n    toKernelSmartAccount\n} from \"permissionless/accounts\"\nimport { getClient } from \"@/registry/batua/lib/batua/helpers/getClient\"\nimport { getSmartAccountClient } from \"@/registry/batua/lib/batua/helpers/getSmartAccountClient\"\nimport {\n    entryPoint07Address,\n    type SmartAccount,\n    toWebAuthnAccount,\n    type UserOperation\n} from \"viem/account-abstraction\"\nimport { useCallback, useEffect, useMemo, useState } from \"react\"\nimport {\n    AlertCircle,\n    Braces,\n    Check,\n    Code,\n    File,\n    Fingerprint,\n    Loader2,\n    Parentheses,\n    SendIcon\n} from \"lucide-react\"\nimport {\n    Accordion,\n    AccordionContent,\n    AccordionItem,\n    AccordionTrigger\n} from \"@/components/ui/accordion\"\nimport { formatEther } from \"ox/Value\"\nimport {\n    type Address,\n    zeroAddress,\n    type Hex,\n    type Transport,\n    type Chain,\n    parseEther\n} from \"viem\"\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\nimport { decodeCallData } from \"@/registry/batua/lib/batua/helpers/decoder\"\nimport {\n    Tooltip,\n    TooltipContent,\n    TooltipProvider,\n    TooltipTrigger\n} from \"@/components/ui/tooltip\"\nimport type { SmartAccountClient } from \"permissionless\"\nimport { sepolia } from \"viem/chains\"\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\"\n\ntype DecodedCallData = {\n    functionName?: string\n    args?: unknown[]\n} | null\n\nconst SendCallsHeader = () => {\n    return (\n        <div className=\"bg-muted/10 rounded-t-lg\">\n            <DialogHeader className=\"pb-0 gap-0\">\n                <div className=\"flex items-center gap-3\">\n                    <div className=\"bg-muted/20 p-2 rounded-full\">\n                        <SendIcon className=\"h-5 w-5\" />\n                    </div>\n                    <DialogTitle className=\"text-xl font-semibold\">\n                        Send Transaction\n                    </DialogTitle>\n                </div>\n                <DialogDescription className=\"text-sm\">\n                    Review and confirm this transaction from your wallet\n                </DialogDescription>\n            </DialogHeader>\n        </div>\n    )\n}\n\nconst CommonCallsSection = ({\n    chainName,\n    dappName,\n    hasPaymaster,\n    refreshingGasCost,\n    gasCost: costInEther,\n    ethPrice\n}: {\n    chainName: string\n    dappName: string\n    hasPaymaster: boolean\n    refreshingGasCost: boolean\n    gasCost: bigint | null\n    ethPrice: number\n}) => {\n    const gasCost = costInEther\n        ? Number(costInEther * BigInt(ethPrice)) / (100 * 10 ** 18)\n        : null\n\n    return (\n        <div className=\"border rounded-lg p-4 bg-muted/5 mb-5\">\n            <div className=\"flex items-center justify-between mb-4 border-b pb-3\">\n                <div className=\"text-sm font-medium flex items-center gap-2\">\n                    <div className=\"w-2 h-2 rounded-full bg-green-500\" />\n                    Network\n                </div>\n                <div className=\"flex items-center bg-muted/10 rounded-full\">\n                    <span className=\"text-sm font-medium\">{chainName}</span>\n                </div>\n            </div>\n\n            <div className=\"flex flex-col w-full\">\n                <div className=\"flex items-start justify-between w-full\">\n                    <div className=\"text-sm font-medium flex items-center gap-2\">\n                        Network fee (est.)\n                    </div>\n\n                    <div className=\"text-sm flex items-center gap-1\">\n                        {!gasCost && (\n                            <>\n                                <Loader2 className=\"h-3 w-3 animate-spin\" />\n                                Calculating...\n                            </>\n                        )}\n                        {gasCost && (\n                            <div\n                                className={`flex gap-2 justify-center items-center  ${hasPaymaster ? \"line-through\" : \"\"} ${refreshingGasCost ? \"text-muted-foreground\" : \"\"}`}\n                            >\n                                {hasPaymaster && (\n                                    <span>\n                                        {gasCost.toLocaleString(\"en-US\", {\n                                            style: \"currency\",\n                                            currency: \"USD\",\n                                            maximumFractionDigits: 2\n                                        })}\n                                    </span>\n                                )}\n\n                                {!hasPaymaster && costInEther && (\n                                    <div\n                                        className={`flex flex-col justify-end ${refreshingGasCost ? \"text-muted-foreground\" : \"\"}`}\n                                    >\n                                        <div className=\"flex justify-end\">\n                                            {gasCost.toLocaleString(\"en-US\", {\n                                                style: \"currency\",\n                                                currency: \"USD\",\n                                                maximumFractionDigits: 2\n                                            })}\n                                        </div>\n                                        <div className=\"flex justify-end text-xs text-muted-foreground\">\n                                            (\n                                            {Number(\n                                                formatEther(costInEther)\n                                            ).toFixed(5)}{\" \"}\n                                            ETH)\n                                        </div>\n                                    </div>\n                                )}\n                            </div>\n                        )}\n                    </div>\n                </div>\n                {hasPaymaster && (\n                    <div className=\"flex justify-end\">\n                        <div className=\"text-xs bg-primary/10 text-primary px-2 py-1 rounded-full mt-2 font-medium\">\n                            Sponsored by {dappName}\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    )\n}\n\nconst CopyAddress = ({ name, value }: { name: string; value: Hex }) => {\n    const [copied, setCopied] = useState(false)\n    return (\n        <TooltipProvider>\n            <Tooltip>\n                <TooltipTrigger asChild>\n                    <button\n                        type=\"button\"\n                        onClick={() => {\n                            navigator.clipboard.writeText(value)\n                            setCopied(true)\n                            setTimeout(() => setCopied(false), 1000)\n                        }}\n                        className=\"relative flex items-center justify-center font-mono text-xs truncate bg-muted/10 hover:bg-muted px-3 py-1.5 rounded-md border-dashed border cursor-pointer transition-colors\"\n                        title=\"Click to copy address\"\n                    >\n                        <span\n                            style={{\n                                visibility: copied ? \"hidden\" : \"visible\"\n                            }}\n                        >\n                            {name}\n                        </span>\n                        <Check\n                            className={`h-4 w-4 text-green-500 absolute ${copied ? \"visible\" : \"invisible\"}`}\n                        />\n                    </button>\n                </TooltipTrigger>\n                <TooltipContent>{value}</TooltipContent>\n            </Tooltip>\n        </TooltipProvider>\n    )\n}\n\nconst RenderArg = ({\n    arg,\n    argIdx\n}: {\n    arg: unknown\n    argIdx: number\n}) => {\n    return (\n        <div className=\"flex items-center justify-between gap-2 bg-black/5 dark:bg-white/5 px-2 py-1.5 rounded-md\">\n            <span className=\"text-xs font-medium px-1.5 py-0.5 bg-muted/20 rounded-full min-w-[40px] text-center whitespace-nowrap\">\n                Arg {argIdx + 1}\n            </span>\n            <span className=\"font-mono text-xs px-2 py-1 rounded truncate flex-shrink\">\n                {(() => {\n                    const argStr =\n                        typeof arg === \"bigint\" ? arg.toString() : String(arg)\n                    if (argStr.length > 30 && argStr.startsWith(\"0x\")) {\n                        return `${argStr.substring(0, 30)}...`\n                    }\n                    return argStr\n                })()}\n            </span>\n        </div>\n    )\n}\nconst RenderArgs = ({ args }: { args: unknown[] }) => {\n    return (\n        <div className=\"mt-3 space-y-2 bg-muted/5 p-3 rounded-md border\">\n            <div className=\"text-xs font-medium flex items-center gap-1.5\">\n                <Parentheses className=\"h-4 w-4\" />\n                Arguments\n            </div>\n            <div className=\"flex flex-col gap-2 mt-2\">\n                {args.map((arg, argIdx) => {\n                    const key =\n                        typeof arg === \"string\" && arg.startsWith(\"0x\")\n                            ? arg\n                            : argIdx\n                    return <RenderArg key={key} arg={arg} argIdx={argIdx} />\n                })}\n            </div>\n        </div>\n    )\n}\n\nconst RawCallData = ({ data }: { data: Hex }) => {\n    const displayData = data || \"0x\"\n\n    return (\n        <div className=\"flex flex-col mt-3\">\n            <Accordion type=\"single\" collapsible className=\"text-xs w-full\">\n                <AccordionItem value=\"data\" className=\"border-none\">\n                    <AccordionTrigger className=\"font-mono text-xs truncate bg-muted/10 px-3 py-2 rounded-md border border-muted/20 hover:bg-muted/20 transition-colors hover:no-underline\">\n                        <div className=\"flex items-center gap-2\">\n                            <Code className=\"h-4 w-4\" />\n                            <div className=\"text-xs font-medium\">\n                                Raw Transaction Data\n                            </div>\n                        </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"font-mono text-xs bg-muted/10 px-3 py-2 rounded-md border border-muted/20 hover:bg-muted/20 transition-colors hover:no-underline break-all\">\n                        {displayData}\n                    </AccordionContent>\n                </AccordionItem>\n            </Accordion>\n        </div>\n    )\n}\n\nconst TransactionDetail = ({\n    index,\n    call,\n    decodedCallData,\n    account\n}: {\n    index: number\n    call: {\n        to?: Address | undefined\n        data?: Hex | undefined\n        value?: Hex | undefined\n    }\n    decodedCallData: DecodedCallData[]\n    account: Account\n}) => {\n    return (\n        <div className=\"border rounded-md p-4 bg-muted/5 hover:bg-muted/10 transition-colors\">\n            {/* Compact transaction diagram */}\n            <div className=\"flex flex-col space-y-2\">\n                {/* From address */}\n                <div className=\"flex items-center gap-2 justify-between\">\n                    <div className=\"w-16 text-xs font-medium flex-1\">From:</div>\n                    <CopyAddress name={account.name} value={account.address} />\n                </div>\n                {/* To address */}\n                <div className=\"flex items-center gap-2 justify-between\">\n                    <div className=\"w-16 text-xs font-medium\">To:</div>\n                    <CopyAddress\n                        name={`${call.to?.slice(0, 6)}...${call.to?.slice(-4)}`}\n                        value={call.to ?? zeroAddress}\n                    />\n                </div>\n                {/* Transaction value */}\n                <div className=\"flex items-center gap-2\">\n                    <div className=\"w-16 text-xs font-medium\">Value:</div>\n                    <div className=\"font-mono text-xs truncate bg-muted/10 px-3 py-1.5 rounded-md flex-1 border border-muted/20 flex justify-end gap-2\">\n                        <span>{formatEther(BigInt(call.value ?? 0))}</span>\n                        <span className=\"font-semibold text-xs\">ETH</span>\n                    </div>\n                </div>\n                {/* Decoded Data */}\n                {call.data && call.data !== \"0x\" && decodedCallData[index] && (\n                    <div className=\"mt-3 border-t pt-3\">\n                        <div className=\"flex items-start gap-2 mb-2\">\n                            <div className=\"flex items-center gap-1.5\">\n                                <Braces className=\"h-4 w-4\" />\n                                <div className=\"text-sm font-medium\">\n                                    Function\n                                </div>\n                            </div>\n                        </div>\n                        <div className=\"flex-1 pl-0\">\n                            <div className=\"font-mono text-xs bg-muted/10 px-3 py-2 rounded-md border border-muted/20 font-semibold\">\n                                {decodedCallData[index]?.functionName ||\n                                    \"Unknown Function\"}\n                            </div>\n                            {decodedCallData[index]?.args && (\n                                <RenderArgs\n                                    args={decodedCallData[index]?.args}\n                                />\n                            )}\n                        </div>\n                    </div>\n                )}\n\n                {/* Raw Data */}\n                {call.data && call.data !== \"0x\" && (\n                    <RawCallData data={call.data} />\n                )}\n            </div>\n        </div>\n    )\n}\n\nexport const SendCalls = ({\n    onComplete,\n    queueRequest,\n    internal,\n    dummy\n}: {\n    onComplete: (args: {\n        queueRequest: QueuedRequest\n    }) => void | Promise<void>\n    queueRequest: QueuedRequest\n    internal: Internal\n    dummy?: boolean\n}) => {\n    const [sendingTransaction, setSendingTransaction] = useState(false)\n    const [error, setError] = useState<string | null>(null)\n    const [decodedCallData, setDecodedCallData] = useState<\n        DecodedCallData[] | null\n    >(null)\n    const [isLoading, setIsLoading] = useState(true)\n    const [smartAccountClient, setSmartAccountClient] =\n        useState<SmartAccountClient<\n            Transport,\n            Chain,\n            SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n        > | null>(null)\n    const [userOperation, setUserOperation] =\n        useState<UserOperation<\"0.7\"> | null>(null)\n    const [refreshingGasCost, setRefreshingGasCost] = useState(false)\n    const [ethPrice, setEthPrice] = useState(1500 * 100)\n    const [gasCost, setGasCost] = useState<bigint | null>(null)\n    const [hasEnoughBalance, setHasEnoughBalance] = useState<boolean>(true)\n    const [paused, setPaused] = useState(false)\n\n    const { request, account, chain, hasPaymaster, calls } = useMemo(() => {\n        setIsLoading(true)\n        const requestStore = RpcRequest.createStore()\n        const request = requestStore.prepare(queueRequest.request)\n        if (request.method !== \"wallet_sendCalls\") {\n            throw new Provider.UnsupportedMethodError()\n        }\n\n        const calls = request.params[0].calls\n\n        const decodedCallDataPromises = Promise.all(\n            calls.map((call) => decodeCallData(call.data as Hex))\n        )\n\n        decodedCallDataPromises.then((results) => {\n            setDecodedCallData(results as DecodedCallData[])\n            setTimeout(() => setIsLoading(false), 500)\n        })\n        const chain = (() => {\n            if (dummy) {\n                return sepolia\n            }\n            const store = internal.store.getState()\n            return store.chain\n        })()\n\n        const hasPaymaster =\n            internal.config.paymaster?.transports[chain.id] !== undefined\n        if (dummy) {\n            setIsLoading(false)\n            return {\n                request,\n                account: {\n                    address: privateKeyToAccount(generatePrivateKey()).address,\n                    type: \"smartAccount\",\n                    name: \"ambitious_deadpool\"\n                } as const,\n                chain: sepolia,\n                hasPaymaster: true,\n                calls: calls\n            }\n        }\n\n        const store = internal.store.getState()\n\n        const account = store.accounts.find(\n            (account) => account.address === request.params[0].from\n        )\n\n        if (!account) {\n            throw new Provider.UnauthorizedError()\n        }\n\n        const capabilities = request.params[0].capabilities\n\n        const key = account.key\n        if (!key) {\n            throw new Provider.UnauthorizedError()\n        }\n\n        const credential = key.credential\n        if (!credential) {\n            throw new Provider.UnauthorizedError()\n        }\n\n        const client = getClient({\n            internal,\n            chainId: internal.store.getState().chain.id\n        })\n\n        toKernelSmartAccount({\n            client,\n            version: \"0.3.1\",\n            owners: [\n                toWebAuthnAccount({\n                    credential: {\n                        id: credential.id,\n                        publicKey: credential.publicKey\n                    }\n                })\n            ],\n            entryPoint: {\n                address: entryPoint07Address,\n                version: \"0.7\"\n            }\n        }).then((smartAccount) => {\n            const smartAccountClient = getSmartAccountClient({\n                account: smartAccount,\n                internal,\n                capabilities,\n                chainId: internal.store.getState().chain.id\n            })\n            setSmartAccountClient(smartAccountClient)\n        })\n\n        return { request, account, chain, hasPaymaster, calls }\n    }, [dummy, queueRequest.request, internal])\n\n    useEffect(() => {\n        if (dummy) {\n            return\n        }\n        const unsubscribe = internal.store.subscribe(\n            (x) => x.price,\n            (price) => {\n                setEthPrice(Number(BigInt((price ?? 1500) * 100)))\n            }\n        )\n\n        return () => {\n            unsubscribe()\n        }\n    }, [dummy, internal.store])\n\n    const onOpenChange = (open: boolean) => {\n        if (!open) {\n            onComplete({\n                queueRequest: {\n                    request: queueRequest.request,\n                    status: \"error\",\n                    error: new Provider.UserRejectedRequestError()\n                }\n            })\n        }\n    }\n\n    useEffect(() => {\n        if (\n            dummy ||\n            !smartAccountClient ||\n            !request.params ||\n            !chain.id ||\n            !hasPaymaster\n        ) {\n            const costInEther = parseEther(\"0.000075\")\n\n            let timer: NodeJS.Timeout | undefined = undefined\n\n            const setCostInEther = () => {\n                setRefreshingGasCost(true)\n                timer = setTimeout(() => {\n                    setGasCost(costInEther)\n                    setRefreshingGasCost(false)\n                }, 1000)\n            }\n\n            const interval = setInterval(() => {\n                setCostInEther()\n            }, 10_000) // updates every 10 seconds\n\n            setCostInEther()\n\n            // cleanup on unmount\n            return () => {\n                clearInterval(interval)\n                if (timer) {\n                    clearTimeout(timer)\n                }\n            }\n        }\n        const estimateUserOperation = async () => {\n            if (!smartAccountClient || paused) {\n                return\n            }\n            try {\n                const client = getClient({ internal, chainId: chain.id })\n                const [userOperation, balance] = await Promise.all([\n                    await smartAccountClient.prepareUserOperation({\n                        calls: request.params[0].calls.map((call) => ({\n                            to: call.to ?? \"0x\",\n                            data: call.data ?? \"0x\",\n                            value: call.value ? BigInt(call.value) : undefined\n                        })),\n                        stateOverride: [\n                            {\n                                address: smartAccountClient.account.address,\n                                balance: parseEther(\"100\")\n                            }\n                        ]\n                    }),\n                    await client.getBalance({\n                        address: smartAccountClient.account.address\n                    })\n                ])\n\n                const gasLimit =\n                    userOperation.callGasLimit +\n                    userOperation.verificationGasLimit +\n                    userOperation.preVerificationGas +\n                    (userOperation.paymasterPostOpGasLimit ?? BigInt(0)) +\n                    (userOperation.preVerificationGas ?? BigInt(0))\n\n                const costInEther = gasLimit * userOperation.maxFeePerGas\n\n                if (balance < costInEther && !hasPaymaster) {\n                    setHasEnoughBalance(false)\n                } else {\n                    setHasEnoughBalance(true)\n                }\n\n                setUserOperation(userOperation)\n                setGasCost(costInEther)\n                setRefreshingGasCost(false)\n            } catch (e) {\n                setError(\n                    e instanceof Error ? e.message : \"Failed to estimate gas\"\n                )\n                setRefreshingGasCost(false)\n            }\n        }\n\n        const interval = setInterval(() => {\n            setRefreshingGasCost(true)\n            estimateUserOperation()\n        }, 10_000) // updates every 10 seconds\n\n        estimateUserOperation()\n\n        // cleanup on unmount\n        return () => clearInterval(interval)\n    }, [\n        dummy,\n        request.params,\n        smartAccountClient,\n        internal,\n        chain.id,\n        hasPaymaster,\n        paused\n    ])\n\n    // Scroll to top when error occurs\n    useEffect(() => {\n        if (error) {\n            const dialogContent = document.querySelector(\".overflow-y-auto\")\n            if (dialogContent) {\n                dialogContent.scrollTop = 0\n            }\n        }\n    }, [error])\n\n    const sendTransaction = useCallback(async () => {\n        if (dummy) {\n            return\n        }\n        try {\n            if (!smartAccountClient || !userOperation) {\n                return\n            }\n            setPaused(true)\n            setError(null)\n\n            setSendingTransaction(true)\n\n            const signature =\n                await smartAccountClient.account.signUserOperation({\n                    ...userOperation\n                })\n\n            const userOpHash = await smartAccountClient.sendUserOperation({\n                ...userOperation,\n                signature\n            })\n\n            onComplete({\n                queueRequest: {\n                    request: queueRequest.request,\n                    status: \"success\",\n                    result: userOpHash\n                }\n            })\n        } catch (error) {\n            setError(\n                error instanceof Error\n                    ? error.message\n                    : \"Failed to send transaction. Please try again.\"\n            )\n        } finally {\n            setSendingTransaction(false)\n            setPaused(false)\n        }\n    }, [\n        dummy,\n        onComplete,\n        queueRequest.request,\n        smartAccountClient,\n        userOperation\n    ])\n\n    return (\n        <Dialog open={!!queueRequest} onOpenChange={onOpenChange}>\n            <DialogContent className=\"sm:max-w-[400px] p-6 h-[75vh] flex justify-start flex-col\">\n                <SendCallsHeader />\n                <div\n                    className={`overflow-y-auto pr-2${!hasEnoughBalance ? \" pb-36\" : \"\"}`}\n                >\n                    {error && (\n                        <Alert variant=\"destructive\" className=\"mb-5\">\n                            <AlertCircle className=\"h-4 w-4\" />\n                            <AlertDescription>{error}</AlertDescription>\n                        </Alert>\n                    )}\n\n                    <CommonCallsSection\n                        chainName={chain.name}\n                        dappName={internal.config.dappName}\n                        hasPaymaster={hasPaymaster}\n                        refreshingGasCost={refreshingGasCost}\n                        gasCost={gasCost}\n                        ethPrice={ethPrice}\n                    />\n\n                    <div className=\"space-y-3\">\n                        <h3 className=\"text-sm font-medium flex items-center gap-2\">\n                            <div className=\"bg-muted/20 p-1 rounded-sm\">\n                                <File className=\"h-4 w-4\" />\n                            </div>\n                            Transaction Details\n                        </h3>\n                        {!isLoading && decodedCallData ? (\n                            <div className=\"space-y-6 pb-20\">\n                                {calls.map((call, index: number) => (\n                                    <TransactionDetail\n                                        // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n                                        key={index}\n                                        call={call}\n                                        decodedCallData={decodedCallData}\n                                        account={account}\n                                        index={index}\n                                    />\n                                ))}\n                            </div>\n                        ) : (\n                            <div className=\"flex justify-center py-4\">\n                                <Loader2 className=\"h-6 w-6 animate-spin text-muted-foreground\" />\n                            </div>\n                        )}\n                    </div>\n                </div>\n\n                <div className=\"absolute bottom-0 left-0 right-0 p-4 bg-background border-t\">\n                    {!hasEnoughBalance && (\n                        <Alert variant=\"destructive\" className=\"mb-3\">\n                            <AlertCircle className=\"h-4 w-4\" />\n                            <AlertDescription>\n                                Insufficient balance to cover gas fees for this\n                                transaction\n                            </AlertDescription>\n                        </Alert>\n                    )}\n                    <Button\n                        variant=\"default\"\n                        className=\"w-full justify-center h-12 text-base font-medium shadow-sm hover:shadow transition-all\"\n                        onClick={sendTransaction}\n                        disabled={sendingTransaction || !hasEnoughBalance}\n                    >\n                        {sendingTransaction ? (\n                            <>\n                                <Loader2 className=\"h-5 w-5 mr-2 animate-spin\" />\n                                <span>Processing Transaction...</span>\n                            </>\n                        ) : (\n                            <>\n                                <Fingerprint className=\"h-4 w-4\" />\n                                <span>Confirm and Send</span>\n                            </>\n                        )}\n                    </Button>\n                </div>\n            </DialogContent>\n        </Dialog>\n    )\n}\n",
      "type": "registry:component",
      "target": "components/batua/SendCalls.tsx"
    },
    {
      "path": "registry/batua/batua.ts",
      "content": "import { type Chain, base, baseSepolia, sepolia } from \"viem/chains\"\nimport { http, type Transport } from \"viem\"\nimport type {\n    Implementation,\n    PriceManager,\n    Internal,\n    State,\n    Storage\n} from \"@/registry/batua/lib/batua/type\"\nimport { Provider } from \"@/registry/batua/lib/batua/provider\"\nimport { local } from \"@/registry/batua/lib/batua/implementations/local\"\nimport { createStore } from \"zustand/vanilla\"\nimport { persist, subscribeWithSelector } from \"zustand/middleware\"\nimport { idb } from \"@/registry/batua/lib/batua/storage\"\nimport { coingeckoPriceManager } from \"@/registry/batua/lib/batua/coingeckoPriceManager\"\n\nconst defaultConfig = {\n    dappName: \"Dapp\",\n    walletName: \"Batua\",\n    chains: [sepolia, baseSepolia, base],\n    announceProvider: true,\n    storage: idb(),\n    rpc: {\n        transports: {\n            [sepolia.id]: http(`https://public.pimlico.io/v2/${sepolia.id}/rpc`)\n        }\n    },\n    bundler: {\n        transports: {\n            [sepolia.id]: http(`https://public.pimlico.io/v2/${sepolia.id}/rpc`)\n        }\n    },\n    implementation: local(),\n    priceManager: coingeckoPriceManager()\n} as const satisfies Config\n\nexport type Config<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = {\n    dappName: string\n    walletName: string\n    announceProvider: boolean\n    chains: chains | readonly [Chain, ...Chain[]]\n    implementation: Implementation\n    storage: Storage\n    rpc: {\n        transports: Record<chains[number][\"id\"], Transport>\n    }\n    paymaster?: {\n        transports: Record<chains[number][\"id\"], Transport>\n        context: unknown\n    }\n    bundler: {\n        transports: Record<chains[number][\"id\"], Transport>\n    }\n    priceManager: PriceManager\n}\n\nexport const Batua = {\n    create: <\n        chains extends readonly [Chain, ...Chain[]] = readonly [\n            Chain,\n            ...Chain[]\n        ]\n    >(parameters?: {\n        chains?: chains | readonly [Chain, ...Chain[]]\n        announceProvider?: boolean\n        storage?: Storage\n        implementation?: Implementation | null\n        rpc?: {\n            transports: Record<chains[number][\"id\"], Transport>\n        }\n        paymaster?: {\n            transports: Record<chains[number][\"id\"], Transport>\n            context: unknown\n        }\n        bundler?: {\n            transports: Record<chains[number][\"id\"], Transport>\n        }\n        dappName?: string\n        walletName?: string\n        priceManager?: PriceManager\n    }) => {\n        const config: Config = {\n            storage: parameters?.storage ?? defaultConfig.storage,\n            chains: parameters?.chains ?? defaultConfig.chains,\n            announceProvider: parameters?.announceProvider ?? true,\n            rpc: parameters?.rpc ?? defaultConfig.rpc,\n            paymaster: parameters?.paymaster,\n            bundler: parameters?.bundler ?? defaultConfig.bundler,\n            implementation:\n                parameters?.implementation ?? defaultConfig.implementation,\n            dappName: parameters?.dappName ?? defaultConfig.dappName,\n            walletName: parameters?.walletName ?? defaultConfig.walletName,\n            priceManager: parameters?.priceManager ?? defaultConfig.priceManager\n        }\n\n        let implementation = config.implementation\n        let priceManager = config.priceManager\n\n        const store = createStore(\n            subscribeWithSelector(\n                persist<State>(\n                    () => ({\n                        accounts: [],\n                        chain: config.chains[0],\n                        requestQueue: [],\n                        price: undefined\n                    }),\n                    {\n                        name: \"batua.store\",\n                        partialize(state) {\n                            return {\n                                accounts: state.accounts.map((account) => ({\n                                    ...account,\n                                    sign: undefined\n                                })),\n                                chain: state.chain,\n                                price: state.price\n                            } as unknown as State\n                        },\n                        storage: config.storage\n                    }\n                )\n            )\n        )\n\n        const internal: Internal = {\n            config,\n            id: crypto.randomUUID(),\n            getImplementation() {\n                return implementation\n            },\n            setImplementation(i) {\n                destroyImplementation()\n                implementation = i\n                destroyImplementation = i.setup({\n                    internal\n                })\n                return destroyImplementation\n            },\n            getPriceManager() {\n                return priceManager\n            },\n            setPriceManager(p) {\n                destroyPriceManager()\n                priceManager = p\n                destroyPriceManager = p.setup({\n                    internal\n                })\n                return destroyPriceManager\n            },\n            store\n        }\n\n        const provider = Provider.from({ internal })\n\n        let destroyImplementation = implementation.setup({\n            internal\n        })\n        let destroyPriceManager = priceManager.setup({\n            internal\n        })\n\n        return {\n            destroy: () => {\n                provider.destroy()\n                destroyImplementation()\n                destroyPriceManager()\n            }\n        }\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua.ts"
    },
    {
      "path": "registry/batua/lib/batua/coingeckoPriceManager.ts",
      "content": "import type { Internal, PriceManager } from \"@/registry/batua/lib/batua/type\"\nimport { z } from \"zod\"\n\nexport const coingeckoPriceManager = (\n    {\n        url,\n        pollingInterval = 30_000 // 30 seconds\n    }: { url: string; pollingInterval?: number } = {\n        url: \"https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=ethereum&x_cg_demo_api_key\"\n    }\n): PriceManager => {\n    const fetchPrice = async (internal: Internal) => {\n        if (typeof window === \"undefined\") return\n        const result = await fetch(url)\n        if (!result.ok) {\n            return\n        }\n        const data = await result.json()\n        const priceSchema = z.array(\n            z.object({\n                current_price: z.number()\n            })\n        )\n        const validatedData = priceSchema.safeParse(data)\n        if (!validatedData.success) {\n            return\n        }\n        internal.store.setState((x) => ({\n            ...x,\n            price: validatedData.data[0].current_price\n        }))\n        return\n    }\n\n    return {\n        setup: ({ internal }) => {\n            const interval = setInterval(() => {\n                fetchPrice(internal)\n            }, pollingInterval)\n\n            // wait for store to be hydrated\n            const timeout = setTimeout(() => {\n                const existingPrice = internal.store.getState().price\n                if (!existingPrice) {\n                    fetchPrice(internal)\n                }\n            }, 100)\n\n            return () => {\n                clearInterval(interval)\n                clearTimeout(timeout)\n            }\n        }\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/coingeckoPriceManager.ts"
    },
    {
      "path": "registry/batua/lib/batua/key.ts",
      "content": "import type { Hex } from \"ox\"\nimport type { Key } from \"@/registry/batua/lib/batua/type\"\n\nexport const fromWebAuthnP256 = ({\n    credential,\n    rpId\n}: {\n    credential: {\n        id: string\n        publicKey: Hex.Hex\n    }\n    rpId: string | undefined\n}): Key => {\n    return {\n        canSign: true,\n        credential: {\n            id: credential.id,\n            publicKey: credential.publicKey\n        },\n        rpId,\n        type: \"webauthn-p256\"\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/key.ts"
    },
    {
      "path": "registry/batua/lib/batua/provider.ts",
      "content": "import { announceProvider } from \"mipd\"\nimport { Address, Hex, Provider as ProviderOx } from \"ox\"\nimport type { Internal } from \"@/registry/batua/lib/batua/type\"\nimport { getClient as getClientHelper } from \"@/registry/batua/lib/batua/helpers/getClient\"\nimport * as Rpc from \"@/registry/batua/lib/batua/typebox/rpc\"\n\nexport const Provider = {\n    from: ({ internal }: { internal: Internal }) => {\n        const { store, getImplementation, config } = internal\n\n        function getClient(chainId_?: Hex.Hex | number | undefined) {\n            const chainId =\n                typeof chainId_ === \"string\" ? Hex.toNumber(chainId_) : chainId_\n            return getClientHelper({ internal, chainId })\n        }\n\n        const emitter = ProviderOx.createEmitter()\n        const provider = ProviderOx.from({\n            ...emitter,\n            request: async (request_) => {\n                let request: Rpc.parseRequest.ReturnType\n                try {\n                    request = Rpc.parseRequest(request_)\n                } catch (e) {\n                    const unsupportedCode = 62\n                    if ((e as any).error?.type !== unsupportedCode) throw e\n\n                    // catch unsupported methods\n                    if (\n                        (request_ as { method: string }).method.startsWith(\n                            \"wallet_\"\n                        )\n                    )\n                        throw new ProviderOx.UnsupportedMethodError()\n                    return getClient().request(request_ as any)\n                }\n\n                const state = store.getState()\n\n                switch (request.method) {\n                    case \"eth_accounts\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n                        const response = state.accounts.map(\n                            (account) => account.address\n                        )\n                        return response\n                    }\n                    case \"eth_chainId\": {\n                        const response = Hex.fromNumber(state.chain.id)\n                        return response\n                    }\n                    case \"wallet_getCapabilities\": {\n                        const value = {\n                            atomicBatch: {\n                                supported: true\n                            },\n                            // createAccount: {\n                            //     supported: true\n                            // },\n                            // permissions: {\n                            //     supported: true\n                            // },\n                            paymasterService: {\n                                supported: true\n                            }\n                        }\n\n                        const capabilities = {} as Record<Hex.Hex, typeof value>\n                        for (const chain of config.chains)\n                            capabilities[Hex.fromNumber(chain.id)] = value\n\n                        return capabilities\n                    }\n                    case \"eth_requestAccounts\": {\n                        if (state.accounts.length > 0) {\n                            return state.accounts.map(\n                                (account) => account.address\n                            )\n                        }\n                        const client = getClient()\n                        const { accounts } =\n                            await getImplementation().actions.loadAccounts({\n                                client,\n                                config,\n                                request,\n                                store\n                            })\n\n                        emitter.emit(\"connect\", {\n                            chainId: Hex.fromNumber(client.chain.id)\n                        })\n                        const response = accounts.map(\n                            (account) => account.address\n                        )\n                        return response\n                    }\n                    case \"eth_sendTransaction\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        const [{ chainId, data = \"0x\", from, to, value }] =\n                            request._decoded.params\n\n                        const client = getClient(chainId)\n\n                        if (chainId && chainId !== client.chain.id)\n                            throw new ProviderOx.ChainDisconnectedError()\n\n                        const account = state.accounts.find((account) =>\n                            Address.isEqual(account.address, from)\n                        )\n                        if (!account) throw new ProviderOx.UnauthorizedError()\n\n                        const hash =\n                            await getImplementation().actions.sendCalls({\n                                account,\n                                calls: [\n                                    {\n                                        data,\n                                        to,\n                                        value\n                                    }\n                                ],\n                                client,\n                                config,\n                                request,\n                                store\n                            })\n\n                        let txHash: Hex.Hex | undefined\n\n                        while (!txHash) {\n                            const receipts =\n                                await getImplementation().actions.getCallsStatus(\n                                    {\n                                        client,\n                                        config,\n                                        request,\n                                        store,\n                                        userOperationHash: hash,\n                                        timeout: 60_000 // 1 minute\n                                    }\n                                )\n\n                            if (receipts.status >= 200) {\n                                txHash = receipts.receipts?.[0]?.transactionHash\n                            }\n                        }\n\n                        return txHash\n                    }\n                    case \"wallet_sendCalls\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        const [{ chainId, calls }] = request._decoded.params\n\n                        const from =\n                            request._decoded.params[0].from ??\n                            state.accounts[0].address\n\n                        const client = getClient(chainId)\n\n                        if (chainId && chainId !== client.chain.id)\n                            throw new ProviderOx.ChainDisconnectedError()\n\n                        const account = state.accounts.find((account) =>\n                            Address.isEqual(account.address, from)\n                        )\n                        if (!account) throw new ProviderOx.UnauthorizedError()\n\n                        const hash =\n                            await getImplementation().actions.sendCalls({\n                                account,\n                                calls,\n                                capabilities:\n                                    request._decoded.params[0]?.capabilities ??\n                                    undefined,\n                                client,\n                                config,\n                                request,\n                                store\n                            })\n\n                        return hash\n                    }\n                    case \"wallet_getCallsStatus\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        const [userOperationHash] = request._decoded.params\n\n                        const client = getClient()\n\n                        const receipts =\n                            await getImplementation().actions.getCallsStatus({\n                                client,\n                                config,\n                                request,\n                                store,\n                                userOperationHash\n                            })\n\n                        return receipts\n                    }\n                    case \"wallet_revokePermissions\": {\n                        if (state.accounts.length === 0)\n                            throw new ProviderOx.DisconnectedError()\n\n                        internal.store.setState((x) => ({\n                            ...x,\n                            accounts: []\n                        }))\n\n                        return undefined\n                    }\n                }\n            }\n        })\n\n        const setup = () => {\n            const unsubscribe_accounts = store.subscribe(\n                (state) => state.accounts,\n                (accounts) => {\n                    emitter.emit(\n                        \"accountsChanged\",\n                        accounts.map((account) => account.address)\n                    )\n                }\n            )\n\n            const unsubscribe_chain = store.subscribe(\n                (state) => state.chain,\n                (chain) => {\n                    emitter.emit(\"chainChanged\", Hex.fromNumber(chain.id))\n                }\n            )\n\n            const unAnnounce =\n                internal.config.announceProvider &&\n                typeof window !== \"undefined\"\n                    ? announceProvider({\n                          info: {\n                              name: \"Batua\",\n                              icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K\",\n                              rdns: \"pimlico.io\",\n                              uuid: internal.id\n                          },\n                          // biome-ignore lint/suspicious/noExplicitAny: viem & announceProvider has different declaration but same thing\n                          provider: provider as any\n                      })\n                    : () => {}\n            return () => {\n                unsubscribe_accounts()\n                unsubscribe_chain()\n                unAnnounce()\n            }\n        }\n\n        const destroy = setup()\n\n        return Object.assign(provider, {\n            destroy\n        })\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/provider.ts"
    },
    {
      "path": "registry/batua/lib/batua/storage.ts",
      "content": "import { createStore, del, get, set } from \"idb-keyval\"\nimport type { Storage } from \"@/registry/batua/lib/batua/type\"\n\nexport const idb = (): Storage => {\n    const store =\n        typeof indexedDB !== \"undefined\"\n            ? createStore(\"batua\", \"store\")\n            : undefined\n    return {\n        async getItem(name) {\n            const value = await get(name, store)\n            if (value === null) return null\n            return value\n        },\n        async removeItem(name) {\n            await del(name, store)\n        },\n        async setItem(name, value) {\n            await set(name, value, store)\n        }\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/storage.ts"
    },
    {
      "path": "registry/batua/lib/batua/type.ts",
      "content": "import type { Chain } from \"viem/chains\"\nimport type { Config } from \"@/registry/batua/batua\"\nimport type { Mutate, StoreApi } from \"zustand/vanilla\"\nimport type { Address, RpcRequest, RpcResponse } from \"ox\"\nimport type * as Rpc from \"@/registry/batua/lib/batua/typebox/rpc\"\nimport type { Hex } from \"ox\"\nimport type { Client, MaybePromise, OneOf, WalletCapabilities } from \"viem\"\nimport type { GetCallsStatusReturnType } from \"viem/experimental\"\n\nexport type Storage = {\n    getItem: <value>(name: string) => MaybePromise<value | null>\n    removeItem: (name: string) => MaybePromise<void>\n    setItem: (name: string, value: unknown) => MaybePromise<void>\n}\n\nexport type Call = {\n    to: Address.Address\n    value?: bigint | undefined\n    data?: Hex.Hex | undefined\n}\n\nexport type Implementation = {\n    actions: {\n        loadAccounts: (parameters: {\n            client: Client\n            config: Config\n            request: Rpc.parseRequest.ReturnType\n            store: Store\n        }) => Promise<{ accounts: readonly Omit<Account, \"name\">[] }>\n\n        sendCalls: (parameters: {\n            calls: readonly Call[]\n            account: Account\n            client: Client\n            config: Config\n            capabilities?: WalletCapabilities | undefined\n            request: Rpc.parseRequest.ReturnType\n            store: Store\n        }) => Promise<Hex.Hex>\n\n        getCallsStatus: (parameters: {\n            client: Client\n            config: Config\n            request: Rpc.parseRequest.ReturnType\n            store: Store\n            userOperationHash: Hex.Hex\n            timeout?: number\n        }) => Promise<\n            Omit<GetCallsStatusReturnType, \"status\" | \"statusCode\"> & {\n                status: number\n            }\n        >\n    }\n    setup: (_: { internal: Internal }) => () => void\n}\n\nexport type PriceManager = {\n    setup: (_: { internal: Internal }) => () => void\n}\n\nexport type Compute<type> = { [key in keyof type]: type[key] } & unknown\nexport type Undefined<type> = {\n    [key in keyof type]?: undefined\n}\n\nexport type BaseKey<type extends string, properties = {}> = Compute<\n    {\n        type: type\n    } & OneOf<\n        | ({\n              canSign: true\n          } & properties)\n        | ({\n              canSign: false\n          } & Undefined<properties>)\n    >\n>\n\nexport type WebAuthnKey = BaseKey<\n    \"webauthn-p256\",\n    {\n        credential: {\n            id: string\n            publicKey: Hex.Hex\n        }\n        rpId: string | undefined\n    }\n>\n\nexport type Key = OneOf<WebAuthnKey>\n\nexport type Account = {\n    address: Address.Address\n    key?: Key\n    type: \"smartAccount\"\n    name: string\n}\n\nexport type QueuedRequest<result = unknown> = {\n    request: RpcRequest.RpcRequest\n} & OneOf<\n    | {\n          status: \"pending\"\n      }\n    | {\n          result: result\n          status: \"success\"\n      }\n    | {\n          error: RpcResponse.ErrorObject\n          status: \"error\"\n      }\n>\n\nexport type State<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = {\n    accounts: readonly Account[]\n    chain: chains[number]\n    requestQueue: readonly QueuedRequest[]\n    price: number | undefined\n}\n\nexport type Store<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = Mutate<\n    StoreApi<State<chains>>,\n    [[\"zustand/subscribeWithSelector\", never], [\"zustand/persist\", any]]\n>\n\nexport type Renderer = {\n    setup: (parameters: { internal: Internal }) => {\n        close: () => void\n        destroy: () => void\n        open: () => void\n        syncRequests: (requests: readonly QueuedRequest[]) => Promise<void>\n    }\n}\n\nexport type Internal<\n    chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]\n> = {\n    config: Config<chains>\n    id: string\n    getImplementation: () => Implementation\n    setImplementation: (i: Implementation) => void\n    store: Store<chains>\n    getPriceManager: () => PriceManager\n    setPriceManager: (p: PriceManager) => void\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/type.ts"
    },
    {
      "path": "registry/batua/lib/batua/implementations/local.ts",
      "content": "import { Hex, Provider, RpcRequest } from \"ox\"\nimport type {\n    Implementation,\n    Internal,\n    Store\n} from \"@/registry/batua/lib/batua/type\"\n\nimport ReactDOM from \"react-dom/client\"\nimport React from \"react\"\nimport { Main } from \"@/registry/batua/components/batua/Main\"\nimport { getBundlerClient } from \"@/registry/batua/lib/batua/helpers/getBundlerClient\"\n\nexport const local = (): Implementation => {\n    const requestStore = RpcRequest.createStore()\n\n    function getProvider(store: Store) {\n        return Provider.from({\n            async request(r) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const request = requestStore.prepare(r as any)\n\n                // When we receive a request, we need to add it to the queue.\n                store.setState((x) => ({\n                    ...x,\n                    requestQueue: [\n                        ...x.requestQueue,\n                        {\n                            request,\n                            status: \"pending\"\n                        }\n                    ]\n                }))\n\n                // We need to wait for the request to be resolved.\n                return new Promise((resolve, reject) => {\n                    const unsubscribe = store.subscribe(\n                        (x) => x.requestQueue,\n                        (requestQueue) => {\n                            // If the queue is empty, reject the request as it will\n                            // never be resolved.\n                            if (requestQueue.length === 0) {\n                                unsubscribe()\n                                reject(new Provider.UserRejectedRequestError())\n                            }\n\n                            // Find the request in the queue based off its JSON-RPC identifier.\n                            const queued = requestQueue.find(\n                                (x) => x.request.id === request.id\n                            )\n                            if (!queued) return\n                            if (\n                                queued.status !== \"success\" &&\n                                queued.status !== \"error\"\n                            )\n                                return\n\n                            // We have a response, we can unsubscribe from the store.\n                            unsubscribe()\n\n                            // If the request was successful, resolve with the result.\n                            if (queued.status === \"success\")\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                resolve(queued.result as any)\n                            // Otherwise, reject with EIP-1193 Provider error.\n                            else reject(Provider.parseError(queued.error))\n\n                            // Remove the request from the queue.\n                            store.setState((x) => ({\n                                ...x,\n                                requestQueue: x.requestQueue.filter(\n                                    (x) => x.request.id !== request.id\n                                )\n                            }))\n                        }\n                    )\n                })\n            }\n        })\n    }\n\n    let internal: Internal\n\n    return {\n        actions: {\n            loadAccounts: async ({ request, store }) => {\n                const provider = getProvider(store)\n\n                const accounts = await (async () => {\n                    if (request.method === \"eth_requestAccounts\") {\n                        const address = await provider.request({\n                            method: \"eth_requestAccounts\"\n                        })\n                        return address.map(\n                            (address) =>\n                                ({\n                                    address,\n                                    type: \"smartAccount\"\n                                }) as const\n                        )\n                    }\n                    throw new Error(\n                        `Cannot load accounts for method: ${request.method}`\n                    )\n                })()\n                return {\n                    accounts\n                }\n            },\n            getCallsStatus: async ({ userOperationHash, timeout, store }) => {\n                const bundlerClient = getBundlerClient({\n                    internal\n                })\n\n                const chainId = store.getState().chain.id\n                try {\n                    const receipt =\n                        await bundlerClient.waitForUserOperationReceipt({\n                            hash: userOperationHash,\n                            timeout: timeout ?? 1_000 // 1 second\n                        })\n                    const userOpStatus = receipt.success\n                    return {\n                        id: userOperationHash,\n                        version: \"1.0\",\n                        chainId,\n                        status: userOpStatus ? 200 : 500,\n                        atomic: true,\n                        receipts: [\n                            {\n                                status: receipt.receipt.status,\n                                logs: receipt.receipt.logs,\n                                blockHash: receipt.receipt.blockHash,\n                                blockNumber: receipt.receipt.blockNumber,\n                                gasUsed: receipt.receipt.gasUsed,\n                                transactionHash: receipt.receipt.transactionHash\n                            }\n                        ]\n                    }\n                } catch {\n                    return {\n                        id: userOperationHash,\n                        version: \"1.0\",\n                        chainId,\n                        atomic: true,\n                        status: 100\n                    }\n                }\n            },\n            sendCalls: async ({ account, store, calls, capabilities }) => {\n                const provider = getProvider(store)\n                return provider.request({\n                    method: \"wallet_sendCalls\",\n                    params: [\n                        {\n                            version: \"1.0\",\n                            from: account.address,\n                            chainId: Hex.fromNumber(store.getState().chain.id),\n                            capabilities,\n                            calls: calls.map((call) => ({\n                                to: call.to,\n                                value: call.value\n                                    ? Hex.fromNumber(call.value)\n                                    : undefined,\n                                data: call.data\n                            }))\n                        }\n                    ]\n                }) as Promise<Hex.Hex>\n            }\n        },\n        setup: ({ internal: internal_ }) => {\n            internal = internal_\n            if (typeof document === \"undefined\") return () => {}\n            const root = document.createElement(\"div\")\n            root.id = internal.id\n            document.body.appendChild(root)\n            ReactDOM.createRoot(root).render(\n                React.createElement(Main, {\n                    internal\n                })\n            )\n\n            return () => {\n                ReactDOM.createRoot(root).unmount()\n                document.body.removeChild(root)\n            }\n        }\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/implementations/local.ts"
    },
    {
      "path": "registry/batua/lib/batua/helpers/decoder.ts",
      "content": "import { decodeFunctionData, type Hex, parseAbiItem, slice } from \"viem\"\nimport { z } from \"zod\"\n\nexport async function decodeCallData(calldata: Hex) {\n    try {\n        return await decodeWithSelector(calldata)\n    } catch {\n        return null\n    }\n}\n\nasync function decodeWithSelector(calldata: Hex) {\n    const selector = slice(calldata, 0, 4)\n    try {\n        // tries to find function signature from openchain and 4bytes\n        const fnInterface = await fetchFunctionInterface({ selector })\n        if (!fnInterface) {\n            throw new Error(\"\")\n        }\n        // decodes calldata with all possible function signatures\n        const decodedTransactions = decodeAllPossibilities({\n            functionSignatures: [fnInterface],\n            calldata\n        })\n\n        if (decodedTransactions.length === 0) {\n            throw new Error(\"Failed to decode calldata with function signature\")\n        }\n\n        const result = decodedTransactions[0]\n        return result\n    } catch {\n        throw new Error(\n            `Failed to find function interface for selector ${selector}`\n        )\n    }\n}\n\nfunction decodeAllPossibilities({\n    functionSignatures,\n    calldata\n}: {\n    functionSignatures: string[]\n    calldata: Hex\n}) {\n    const results: unknown[] = []\n    for (const signature of functionSignatures) {\n        try {\n            const abi = parseAbiItem(`function ${signature}`)\n            const parsedTransaction = decodeFunctionData({\n                abi: [abi],\n                data: calldata\n            })\n            if (parsedTransaction) {\n                results.push(parsedTransaction)\n            }\n        } catch {}\n    }\n    return results\n}\n\nexport async function fetchFunctionInterface({\n    selector\n}: {\n    selector: string\n}): Promise<string | null> {\n    const openChainData = await fetchFunctionFromOpenchain({ selector })\n\n    let result: string | null = null\n    // giving priority to openchain data because it filters spam like: `mintEfficientN2M_001Z5BWH` for 0x00000000\n    if (openChainData) {\n        result = openChainData[0].name\n    } else {\n        const fourByteData = await fetchFunctionFrom4Bytes({ selector })\n        if (fourByteData) {\n            result = fourByteData[0].text_signature\n        }\n    }\n\n    return result\n}\nexport const fetchFunctionInterface4ByteSchema = z.object({\n    count: z.number(),\n    results: z.array(\n        z.object({\n            id: z.number(),\n            created_at: z.string(),\n            text_signature: z.string(),\n            hex_signature: z.string()\n        })\n    )\n})\n\nasync function fetchFunctionFrom4Bytes({ selector }: { selector: string }) {\n    try {\n        const requestUrl = new URL(\n            \"https://www.4byte.directory/api/v1/signatures/\"\n        )\n        requestUrl.searchParams.append(\"hex_signature\", selector)\n        const response = await fetch(requestUrl)\n        const data = await response.json()\n        const parsedData = fetchFunctionInterface4ByteSchema.parse(data)\n        if (parsedData.count === 0) {\n            throw new Error(\n                `4bytes API failed to find function interface with selector ${selector}`\n            )\n        }\n        return parsedData.results\n    } catch {\n        return null\n    }\n}\n\nexport const fetchFunctionInterfaceOpenApiSchema = z.object({\n    ok: z.boolean(),\n    result: z.object({\n        function: z.record(\n            z\n                .array(\n                    z.object({\n                        name: z.string(),\n                        filtered: z.boolean()\n                    })\n                )\n                .optional()\n        ),\n        event: z.record(\n            z\n                .array(\n                    z.object({\n                        name: z.string(),\n                        filtered: z.boolean()\n                    })\n                )\n                .optional()\n        )\n    })\n})\n\nasync function fetchFunctionFromOpenchain({ selector }: { selector: string }) {\n    try {\n        const requestUrl = new URL(\n            \"https://api.openchain.xyz/signature-database/v1/lookup\"\n        )\n        requestUrl.searchParams.append(\"function\", selector)\n        const response = await fetch(requestUrl)\n        const data = await response.json()\n        const parsedData = fetchFunctionInterfaceOpenApiSchema.parse(data)\n        if (!parsedData.ok) {\n            throw new Error(\n                `Openchain API failed to find function interface with selector ${selector}`\n            )\n        }\n        return parsedData.result.function[selector]\n    } catch {\n        return null\n    }\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/helpers/decoder.ts"
    },
    {
      "path": "registry/batua/lib/batua/helpers/getBundlerClient.ts",
      "content": "import type { Chain, Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/lib/batua/type\"\nimport {\n    type BundlerClient,\n    createBundlerClient\n} from \"viem/account-abstraction\"\n\nconst clientCache = new Map<string, BundlerClient<Transport, Chain>>()\n\nexport const getBundlerClient = ({\n    internal,\n    chainId\n}: { internal: Internal; chainId?: number | undefined }): BundlerClient<\n    Transport,\n    Chain\n> => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.bundler.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n    const client = createBundlerClient({\n        chain,\n        transport: transport,\n        pollingInterval: 1_000\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/helpers/getBundlerClient.ts"
    },
    {
      "path": "registry/batua/lib/batua/helpers/getClient.ts",
      "content": "import {\n    type PublicClient,\n    type Chain,\n    type Transport,\n    createPublicClient\n} from \"viem\"\nimport type { Internal } from \"@/registry/batua/lib/batua/type\"\n\nconst clientCache = new Map<string, PublicClient<Transport, Chain>>()\n\nexport const getClient = ({\n    internal,\n    chainId\n}: { internal: Internal; chainId: number | undefined }): PublicClient<\n    Transport,\n    Chain\n> => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.rpc.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n    const client = createPublicClient({\n        chain,\n        transport: transport,\n        pollingInterval: 1_000\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/helpers/getClient.ts"
    },
    {
      "path": "registry/batua/lib/batua/helpers/getPaymasterClient.ts",
      "content": "import type { Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/lib/batua/type\"\nimport {\n    createPaymasterClient,\n    type PaymasterClient\n} from \"viem/account-abstraction\"\n\nconst clientCache = new Map<string, PaymasterClient<Transport>>()\n\nexport const getPaymasterClient = ({\n    internal,\n    chainId\n}: {\n    internal: Internal\n    chainId: number | undefined\n}): PaymasterClient<Transport> | null => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) return null\n\n    const transport = config.paymaster?.transports[chain.id]\n    if (!transport) return null\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            return null\n        }\n\n        return client\n    }\n    const client = createPaymasterClient({\n        transport: transport,\n        pollingInterval: 1_000\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/helpers/getPaymasterClient.ts"
    },
    {
      "path": "registry/batua/lib/batua/helpers/getSmartAccountClient.ts",
      "content": "import { http, type WalletCapabilities, type Chain, type Transport } from \"viem\"\nimport type { Internal } from \"@/registry/batua/lib/batua/type\"\nimport {\n    createPaymasterClient,\n    type PaymasterClient,\n    type SmartAccount\n} from \"viem/account-abstraction\"\nimport type { KernelSmartAccountImplementation } from \"permissionless/accounts\"\nimport {\n    createSmartAccountClient,\n    type SmartAccountClient\n} from \"permissionless\"\nimport { createPimlicoClient } from \"permissionless/clients/pimlico\"\nimport { getPaymasterClient } from \"@/registry/batua/lib/batua/helpers/getPaymasterClient\"\n\nconst clientCache = new Map<\n    string,\n    SmartAccountClient<\n        Transport,\n        Chain,\n        SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n    >\n>()\n\nexport const getSmartAccountClient = ({\n    account,\n    internal,\n    chainId,\n    capabilities\n}: {\n    account: SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n    internal: Internal\n    chainId: number | undefined\n    capabilities: WalletCapabilities | undefined\n}): SmartAccountClient<\n    Transport,\n    Chain,\n    SmartAccount<KernelSmartAccountImplementation<\"0.7\">>\n> => {\n    const { config, id, store } = internal\n    const { chains } = config\n\n    const state = store.getState()\n    const chain = chains.find((chain) => chain.id === chainId || state.chain.id)\n    if (!chain) throw new Error(\"chain not found\")\n\n    const transport = config.bundler.transports[chain.id]\n    if (!transport) throw new Error(\"transport not found\")\n\n    const key = [id, chainId].filter(Boolean).join(\":\")\n    if (clientCache.has(key)) {\n        const client = clientCache.get(key)\n\n        // should never happen but TS\n        if (!client) {\n            throw new Error(\"client not found\")\n        }\n\n        return client\n    }\n\n    const pimlicoClient = createPimlicoClient({\n        chain,\n        transport: transport\n    })\n\n    let paymaster: PaymasterClient | undefined\n\n    if (capabilities?.paymasterService?.url) {\n        paymaster = createPaymasterClient({\n            transport: http(capabilities.paymasterService.url)\n        })\n    }\n\n    if (!paymaster) {\n        paymaster =\n            getPaymasterClient({\n                internal,\n                chainId: internal.store.getState().chain.id\n            }) ?? undefined\n    }\n\n    const client = createSmartAccountClient({\n        chain,\n        bundlerTransport: transport,\n        account,\n        paymaster,\n        paymasterContext: config.paymaster?.context,\n        userOperation: {\n            estimateFeesPerGas: async () =>\n                (await pimlicoClient.getUserOperationGasPrice()).fast\n        }\n    })\n    clientCache.set(key, client)\n    return client\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/helpers/getSmartAccountClient.ts"
    },
    {
      "path": "registry/batua/lib/batua/helpers/randomWords.ts",
      "content": "const adjectives = [\n    \"abandoned\",\n    \"brilliant\",\n    \"cheerful\",\n    \"creative\",\n    \"delightful\",\n    \"acoustic\",\n    \"adorable\",\n    \"amazing\",\n    \"ambiguous\",\n    \"ambitious\",\n    \"amused\",\n    \"amusing\",\n    \"ancient\",\n    \"aromatic\",\n    \"aspiring\",\n    \"awesome\",\n    \"bent\",\n    \"big\",\n    \"generous\",\n    \"radiant\",\n    \"black\",\n    \"blue\",\n    \"blushing\",\n    \"joyful\",\n    \"uplifting\",\n    \"bouncy\",\n    \"brainy\",\n    \"brave\",\n    \"breezy\",\n    \"brief\",\n    \"bright\",\n    \"broad\",\n    \"harmonious\",\n    \"brown\",\n    \"bumpy\",\n    \"burly\",\n    \"busy\",\n    \"calm\",\n    \"careful\",\n    \"caring\",\n    \"certain\",\n    \"charming\",\n    \"cheerful\",\n    \"chemical\",\n    \"chief\",\n    \"chilly\",\n    \"chubby\",\n    \"chunky\",\n    \"sunny\",\n    \"classy\",\n    \"clean\",\n    \"clear\",\n    \"clever\",\n    \"cloudy\",\n    \"closed\",\n    \"graceful\",\n    \"warm\",\n    \"colorful\",\n    \"colossal\",\n    \"common\",\n    \"complete\",\n    \"complex\",\n    \"confident\",\n    \"admired\",\n    \"focused\",\n    \"conscious\",\n    \"cooing\",\n    \"cool\",\n    \"wise\",\n    \"cuddly\",\n    \"cultured\",\n    \"curious\",\n    \"curly\",\n    \"curved\",\n    \"curvy\",\n    \"cute\",\n    \"hopeful\",\n    \"daffy\",\n    \"daily\",\n    \"shining\",\n    \"dapper\",\n    \"vivid\",\n    \"dashing\",\n    \"dazzling\",\n    \"dear\",\n    \"deep\",\n    \"angelic\",\n    \"steady\",\n    \"refreshing\",\n    \"sparkling\",\n    \"eager\",\n    \"early\",\n    \"easy\",\n    \"elite\",\n    \"eminent\",\n    \"fulfilled\",\n    \"equal\",\n    \"even\",\n    \"exotic\",\n    \"fair\",\n    \"faithful\",\n    \"familiar\",\n    \"famous\",\n    \"fancy\",\n    \"fantastic\",\n    \"far\",\n    \"fast\",\n    \"fat\",\n    \"flawless\",\n    \"fearless\",\n    \"fine\",\n    \"first\",\n    \"fixed\",\n    \"reliable\",\n    \"flashy\",\n    \"flat\",\n    \"flawless\",\n    \"sturdy\",\n    \"flippant\",\n    \"flowery\",\n    \"fluffy\",\n    \"foamy\",\n    \"free\",\n    \"freezing\",\n    \"fresh\",\n    \"friendly\",\n    \"funny\",\n    \"furry\",\n    \"futuristic\",\n    \"fuzzy\",\n    \"giant\",\n    \"gifted\",\n    \"gigantic\",\n    \"glamorous\",\n    \"glorious\",\n    \"glossy\",\n    \"good\",\n    \"goofy\",\n    \"gorgeous\",\n    \"graceful\",\n    \"gray\",\n    \"great\",\n    \"giving\",\n    \"green\",\n    \"grey\",\n    \"groovy\",\n    \"handy\",\n    \"happy\",\n    \"hard\",\n    \"gentle\",\n    \"heavy\",\n    \"decisive\",\n    \"high\",\n    \"hot\",\n    \"huge\",\n    \"glowing\",\n    \"lawful\",\n    \"jazzy\",\n    \"jittery\",\n    \"keen\",\n    \"kind\",\n    \"known\",\n    \"lively\",\n    \"large\",\n    \"last\",\n    \"late\",\n    \"active\",\n    \"lean\",\n    \"left\",\n    \"legal\",\n    \"lethal\",\n    \"light\",\n    \"little\",\n    \"lively\",\n    \"living\",\n    \"social\",\n    \"long\",\n    \"loose\",\n    \"loud\",\n    \"lovely\",\n    \"loving\",\n    \"low\",\n    \"respected\",\n    \"lucky\",\n    \"lumpy\",\n    \"lush\",\n    \"luxuriant\",\n    \"truthful\",\n    \"lyrical\",\n    \"magenta\",\n    \"magical\",\n    \"majestic\",\n    \"many\",\n    \"massive\",\n    \"married\",\n    \"marvelous\",\n    \"material\",\n    \"mature\",\n    \"kind\",\n    \"medical\",\n    \"melodic\",\n    \"melted\",\n    \"organized\",\n    \"mighty\",\n    \"military\",\n    \"milky\",\n    \"minor\",\n    \"misty\",\n    \"mixed\",\n    \"singing\",\n    \"modern\",\n    \"motionless\",\n    \"mushy\",\n    \"expressive\",\n    \"mysterious\",\n    \"wise\",\n    \"nappy\",\n    \"broad\",\n    \"pleasant\",\n    \"natural\",\n    \"neat\",\n    \"nebulous\",\n    \"self-sufficient\",\n    \"calm\",\n    \"new\",\n    \"next\",\n    \"nice\",\n    \"nifty\",\n    \"noisy\",\n    \"normal\",\n    \"nostalgic\",\n    \"nosy\",\n    \"numerous\",\n    \"unique\",\n    \"old\",\n    \"omniscient\",\n    \"open\",\n    \"opposite\",\n    \"optimal\",\n    \"orange\",\n    \"ordinary\",\n    \"organic\",\n    \"outgoing\",\n    \"outstanding\",\n    \"oval\",\n    \"humble\",\n    \"overjoyed\",\n    \"valued\",\n    \"colorful\",\n    \"panoramic\",\n    \"parallel\",\n    \"hydrated\",\n    \"past\",\n    \"peaceful\",\n    \"perfect\",\n    \"perpetual\",\n    \"petite\",\n    \"pink\",\n    \"plain\",\n    \"polite\",\n    \"powerful\",\n    \"premium\",\n    \"pretty\",\n    \"previous\",\n    \"productive\",\n    \"public\",\n    \"purple\",\n    \"clear\",\n    \"quick\",\n    \"quiet\",\n    \"rainy\",\n    \"rapid\",\n    \"rare\",\n    \"real\",\n    \"red\",\n    \"essential\",\n    \"reflective\",\n    \"regular\",\n    \"remarkable\",\n    \"rich\",\n    \"right\",\n    \"robust\",\n    \"romantic\",\n    \"round\",\n    \"happy\",\n    \"safe\",\n    \"salty\",\n    \"same\",\n    \"secret\",\n    \"serious\",\n    \"shallow\",\n    \"sharp\",\n    \"shiny\",\n    \"pleasant\",\n    \"short\",\n    \"silent\",\n    \"silky\",\n    \"silly\",\n    \"simple\",\n    \"healthy\",\n    \"energetic\",\n    \"slim\",\n    \"smooth\",\n    \"slippery\",\n    \"neat\",\n    \"swift\",\n    \"small\",\n    \"smart\",\n    \"smiling\",\n    \"smooth\",\n    \"soft\",\n    \"solid\",\n    \"sour\",\n    \"sparkling\",\n    \"special\",\n    \"spicy\",\n    \"spooky\",\n    \"spotty\",\n    \"square\",\n    \"fresh\",\n    \"steady\",\n    \"steep\",\n    \"clean\",\n    \"flexible\",\n    \"stormy\",\n    \"familiar\",\n    \"striped\",\n    \"strong\",\n    \"sturdy\",\n    \"sudden\",\n    \"superb\",\n    \"supreme\",\n    \"sweet\",\n    \"swift\",\n    \"talented\",\n    \"tan\",\n    \"cheerful\",\n    \"relaxed\",\n    \"thankful\",\n    \"thick\",\n    \"thin\",\n    \"third\",\n    \"tidy\",\n    \"tiny\",\n    \"tired\",\n    \"exciting\",\n    \"tough\",\n    \"tranquil\",\n    \"tricky\",\n    \"true\",\n    \"typical\",\n    \"even\",\n    \"unique\",\n    \"famous\",\n    \"special\",\n    \"useful\",\n    \"forgiving\",\n    \"violet\",\n    \"volatile\",\n    \"wakeful\",\n    \"wandering\",\n    \"warm\",\n    \"watery\",\n    \"wealthy\",\n    \"wet\",\n    \"white\",\n    \"whole\",\n    \"wide\",\n    \"wild\",\n    \"windy\",\n    \"wise\",\n    \"wonderful\",\n    \"wooden\",\n    \"focused\",\n    \"workable\",\n    \"assured\",\n    \"worthy\",\n    \"yellow\",\n    \"yielding\",\n    \"young\",\n    \"youthful\",\n    \"yummy\",\n    \"zippy\"\n]\n\nconst nouns = [\n    \"aaron_stack\",\n    \"champion\",\n    \"absorbing_man\",\n    \"adam_destine\",\n    \"adam_warlock\",\n    \"agent_brand\",\n    \"agent_zero\",\n    \"albert_cleary\",\n    \"alex_power\",\n    \"alex_wilder\",\n    \"alice\",\n    \"amazoness\",\n    \"amphibian\",\n    \"angel\",\n    \"anita_blake\",\n    \"guardian\",\n    \"anthem\",\n    \"miracle\",\n    \"aqueduct\",\n    \"arachne\",\n    \"archangel\",\n    \"arclight\",\n    \"ares\",\n    \"argent\",\n    \"avengers\",\n    \"azazel\",\n    \"banshee\",\n    \"baron_strucker\",\n    \"baron_zemo\",\n    \"barracuda\",\n    \"bastion\",\n    \"beast\",\n    \"bedlam\",\n    \"ben_grimm\",\n    \"ben_parker\",\n    \"ben_urich\",\n    \"betty_brant\",\n    \"betty_ross\",\n    \"beyonder\",\n    \"big_bertha\",\n    \"bill_hollister\",\n    \"bishop\",\n    \"black_bird\",\n    \"black_bolt\",\n    \"black_cat\",\n    \"black_crow\",\n    \"black_knight\",\n    \"black_panther\",\n    \"black_queen\",\n    \"black_tarantula\",\n    \"black_tom\",\n    \"black_widow\",\n    \"blackheart\",\n    \"blacklash\",\n    \"blade\",\n    \"blazing_skull\",\n    \"blindfold\",\n    \"blink\",\n    \"blizzard\",\n    \"blob\",\n    \"blockbuster\",\n    \"blonde_phantom\",\n    \"bloodaxe\",\n    \"bloodscream\",\n    \"bloodstorm\",\n    \"bloodstrike\",\n    \"blue_blade\",\n    \"blue_marvel\",\n    \"blue_shield\",\n    \"blur\",\n    \"boom_boom\",\n    \"boomer\",\n    \"boomerang\",\n    \"bromley\",\n    \"brood\",\n    \"brother_voodoo\",\n    \"bruce_banner\",\n    \"bucky\",\n    \"bug\",\n    \"bulldozer\",\n    \"bullseye\",\n    \"bushwacker\",\n    \"butterfly\",\n    \"cable\",\n    \"callisto\",\n    \"calypso\",\n    \"cammi\",\n    \"cannonball\",\n    \"captain_america\",\n    \"captain_britain\",\n    \"captain_cross\",\n    \"captain_flint\",\n    \"captain_marvel\",\n    \"captain_midlands\",\n    \"captain_stacy\",\n    \"captain_universe\",\n    \"cardiac\",\n    \"caretaker\",\n    \"cargill\",\n    \"carlie_cooper\",\n    \"carmella_unuscione\",\n    \"harmony\",\n    \"cassandra_nova\",\n    \"catseye\",\n    \"celestials\",\n    \"centennial\",\n    \"cerebro\",\n    \"cerise\",\n    \"chamber\",\n    \"chameleon\",\n    \"champions\",\n    \"changeling\",\n    \"charles_xavier\",\n    \"chat\",\n    \"chimera\",\n    \"christian_walker\",\n    \"chronomancer\",\n    \"clea\",\n    \"clint_barton\",\n    \"cloak\",\n    \"cobalt_man\",\n    \"colleen_wing\",\n    \"colonel_america\",\n    \"colossus\",\n    \"corsair\",\n    \"crusher_hogan\",\n    \"crystal\",\n    \"cyclops\",\n    \"dagger\",\n    \"daimon_hellstrom\",\n    \"dakota_north\",\n    \"daredevil\",\n    \"dark_beast\",\n    \"dark_phoenix\",\n    \"darkhawk\",\n    \"darkstar\",\n    \"darwin\",\n    \"dazzler\",\n    \"deadpool\",\n    \"deathbird\",\n    \"lifesaver\",\n    \"demogoblin\",\n    \"devos\",\n    \"dexter_bennett\",\n    \"diamondback\",\n    \"doctor_doom\",\n    \"doctor_faustus\",\n    \"doctor_octopus\",\n    \"doctor_spectrum\",\n    \"doctor_strange\",\n    \"domino\",\n    \"donald_blake\",\n    \"jubilee\",\n    \"doorman\",\n    \"dorian_gray\",\n    \"dormammu\",\n    \"paladin\",\n    \"dragon_lord\",\n    \"dragon_man\",\n    \"drax\",\n    \"dreadnoughts\",\n    \"dreaming_celestial\",\n    \"dust\",\n    \"earthquake\",\n    \"echo\",\n    \"eddie_brock\",\n    \"edwin_jarvis\",\n    \"ego\",\n    \"electro\",\n    \"elektra\",\n    \"emma_frost\",\n    \"enchantress\",\n    \"ender_wiggin\",\n    \"energizer\",\n    \"epoch\",\n    \"eternals\",\n    \"eternity\",\n    \"excalibur\",\n    \"exiles\",\n    \"exodus\",\n    \"expediter\",\n    \"ezekiel\",\n    \"ezekiel_stane\",\n    \"fabian_cortez\",\n    \"falcon\",\n    \"fallen_one\",\n    \"bounty\",\n    \"fantastic_four\",\n    \"fat_cobra\",\n    \"felicia_hardy\",\n    \"fenris\",\n    \"firebird\",\n    \"firebrand\",\n    \"firedrake\",\n    \"firelord\",\n    \"firestar\",\n    \"fixer\",\n    \"flatman\",\n    \"forge\",\n    \"forgotten_one\",\n    \"frank_castle\",\n    \"franklin_richards\",\n    \"franklin_storm\",\n    \"freak\",\n    \"frightful_four\",\n    \"frog_thor\",\n    \"gabe_jones\",\n    \"galactus\",\n    \"gambit\",\n    \"gamma_corps\",\n    \"gamora\",\n    \"gargoyle\",\n    \"garia\",\n    \"gateway\",\n    \"gauntlet\",\n    \"genesis\",\n    \"george_stacy\",\n    \"gertrude_yorkes\",\n    \"ghost_rider\",\n    \"giant_girl\",\n    \"giant_man\",\n    \"gideon\",\n    \"gladiator\",\n    \"glorian\",\n    \"goblin_queen\",\n    \"golden_guardian\",\n    \"goliath\",\n    \"gorgon\",\n    \"gorilla_man\",\n    \"grandmaster\",\n    \"gravity\",\n    \"green_goblin\",\n    \"gressill\",\n    \"grey_gargoyle\",\n    \"greymalkin\",\n    \"grim_reaper\",\n    \"groot\",\n    \"guardian\",\n    \"guardsmen\",\n    \"gunslinger\",\n    \"gwen_stacy\",\n    \"hairball\",\n    \"hammerhead\",\n    \"hannibal_king\",\n    \"hardball\",\n    \"harpoon\",\n    \"harrier\",\n    \"harry_osborn\",\n    \"havok\",\n    \"hawkeye\",\n    \"hedge_knight\",\n    \"hellcat\",\n    \"hellfire_club\",\n    \"hellion\",\n    \"hemingway\",\n    \"hercules\",\n    \"hex\",\n    \"hiroim\",\n    \"hitman\",\n    \"hobgoblin\",\n    \"hulk\",\n    \"human_cannonball\",\n    \"human_fly\",\n    \"human_robot\",\n    \"human_torch\",\n    \"husk\",\n    \"hydra\",\n    \"iceman\",\n    \"ikaris\",\n    \"imperial_guard\",\n    \"impossible_man\",\n    \"inertia\",\n    \"infant_terrible\",\n    \"inhumans\",\n    \"ink\",\n    \"invaders\",\n    \"invisible_woman\",\n    \"iron_fist\",\n    \"iron_lad\",\n    \"iron_man\",\n    \"iron_monger\",\n    \"iron_patriot\",\n    \"ironclad\",\n    \"jack_flag\",\n    \"jack_murdock\",\n    \"jack_power\",\n    \"jackal\",\n    \"jackpot\",\n    \"james_howlett\",\n    \"jamie_braddock\",\n    \"jane_foster\",\n    \"jasper_sitwell\",\n    \"jazinda\",\n    \"jean_grey\",\n    \"jetstream\",\n    \"jigsaw\",\n    \"jimmy_woo\",\n    \"jocasta\",\n    \"johnny_blaze\",\n    \"johnny_storm\",\n    \"joseph\",\n    \"joshua_kane\",\n    \"joystick\",\n    \"jubilee\",\n    \"juggernaut\",\n    \"junta\",\n    \"justice\",\n    \"justin_hammer\",\n    \"kabuki\",\n    \"kang\",\n    \"karen_page\",\n    \"karma\",\n    \"karnak\",\n    \"kat_farrell\",\n    \"kate_bishop\",\n    \"katie_power\",\n    \"ken_ellis\",\n    \"khan\",\n    \"kid_colt\",\n    \"killer_shrike\",\n    \"killmonger\",\n    \"killraven\",\n    \"king_bedlam\",\n    \"king_cobra\",\n    \"kingpin\",\n    \"kinsey_walden\",\n    \"kitty_pryde\",\n    \"klaw\",\n    \"komodo\",\n    \"korath\",\n    \"korg\",\n    \"korvac\",\n    \"kree\",\n    \"krista_starr\",\n    \"kronos\",\n    \"kulan_gath\",\n    \"kylun\",\n    \"la_nuit\",\n    \"lady_bullseye\",\n    \"lady_deathstrike\",\n    \"lady_mastermind\",\n    \"lady_ursula\",\n    \"lady_vermin\",\n    \"lake\",\n    \"landau\",\n    \"layla_miller\",\n    \"leader\",\n    \"leech\",\n    \"legion\",\n    \"lenny_balinger\",\n    \"leo\",\n    \"leopardon\",\n    \"leper_queen\",\n    \"lester\",\n    \"lethal_legion\",\n    \"lifeguard\",\n    \"lightspeed\",\n    \"lila_cheney\",\n    \"lilandra\",\n    \"lilith\",\n    \"lily_hollister\",\n    \"lionheart\",\n    \"living_lightning\",\n    \"living_mummy\",\n    \"living_tribunal\",\n    \"liz_osborn\",\n    \"lizard\",\n    \"loa\",\n    \"lockheed\",\n    \"lockjaw\",\n    \"logan\",\n    \"loki\",\n    \"loners\",\n    \"longshot\",\n    \"lord_hawal\",\n    \"lord_tyger\",\n    \"lorna_dane\",\n    \"luckman\",\n    \"lucky_pierre\",\n    \"luke_cage\",\n    \"luminals\",\n    \"lyja\",\n    \"ma_gnuci\",\n    \"mac_gargan\",\n    \"mach_iv\",\n    \"machine_man\",\n    \"mad_thinker\",\n    \"madame_hydra\",\n    \"madame_masque\",\n    \"madame_web\",\n    \"maddog\",\n    \"madelyne_pryor\",\n    \"madripoor\",\n    \"madrox\",\n    \"maelstrom\",\n    \"maestro\",\n    \"magdalene\",\n    \"maggott\",\n    \"magik\",\n    \"maginty\",\n    \"magma\",\n    \"magneto\",\n    \"magus\",\n    \"major_mapleleaf\",\n    \"makkari\",\n    \"malcolm_colcord\",\n    \"joy\",\n    \"mandarin\",\n    \"mandrill\",\n    \"mandroid\",\n    \"manta\",\n    \"mantis\",\n    \"marauders\",\n    \"maria_hill\",\n    \"mariko_yashida\",\n    \"marrow\",\n    \"marten_broadcloak\",\n    \"martin_li\",\n    \"marvel_apes\",\n    \"marvel_boy\",\n    \"marvel_zombies\",\n    \"marvex\",\n    \"masked_marvel\",\n    \"masque\",\n    \"master_chief\",\n    \"master_mold\",\n    \"mastermind\",\n    \"mathemanic\",\n    \"matthew_murdock\",\n    \"mattie_franklin\",\n    \"mauler\",\n    \"maverick\",\n    \"maximus\",\n    \"may_parker\",\n    \"medusa\",\n    \"meggan\",\n    \"meltdown\",\n    \"menace\",\n    \"mentallo\",\n    \"mentor\",\n    \"mephisto\",\n    \"mephistopheles\",\n    \"mercury\",\n    \"mesmero\",\n    \"metal_master\",\n    \"meteorite\",\n    \"micromacro\",\n    \"microbe\",\n    \"microchip\",\n    \"micromax\",\n    \"midnight\",\n    \"miek\",\n    \"mikhail_rasputin\",\n    \"millenium_guard\",\n    \"mimic\",\n    \"mindworm\",\n    \"miracleman\",\n    \"miss_america\",\n    \"mister_fear\",\n    \"mister_sinister\",\n    \"misty_knight\",\n    \"mockingbird\",\n    \"moira_mactaggert\",\n    \"mojo\",\n    \"mole_man\",\n    \"molecule_man\",\n    \"molly_hayes\",\n    \"molten_man\",\n    \"mongoose\",\n    \"mongu\",\n    \"hero\",\n    \"moon_knight\",\n    \"moondragon\",\n    \"moonstone\",\n    \"morbius\",\n    \"mordo\",\n    \"morg\",\n    \"morgan_stark\",\n    \"morlocks\",\n    \"morlun\",\n    \"morph\",\n    \"mother_askani\",\n    \"mulholland_black\",\n    \"multiple_man\",\n    \"clarity\",\n    \"mystique\",\n    \"namor\",\n    \"namora\",\n    \"namorita\",\n    \"naoko\",\n    \"natasha_romanoff\",\n    \"nebula\",\n    \"nehzno\",\n    \"nekra\",\n    \"nemesis\",\n    \"network\",\n    \"newton_destine\",\n    \"next_avengers\",\n    \"nextwave\",\n    \"nick_fury\",\n    \"nico_minoru\",\n    \"nicolaos\",\n    \"night_nurse\",\n    \"night_thrasher\",\n    \"nightcrawler\",\n    \"nighthawk\",\n    \"dream\",\n    \"nightshade\",\n    \"nitro\",\n    \"nocturne\",\n    \"nomad\",\n    \"norman_osborn\",\n    \"norrin_radd\",\n    \"northstar\",\n    \"nova\",\n    \"nuke\",\n    \"obadiah_stane\",\n    \"odin\",\n    \"ogun\",\n    \"old_lace\",\n    \"omega_flight\",\n    \"omega_red\",\n    \"omega_sentinel\",\n    \"onslaught\",\n    \"oracle\",\n    \"orphan\",\n    \"otto_octavius\",\n    \"outlaw_kid\",\n    \"overlord\",\n    \"owl\",\n    \"ozymandias\",\n    \"paibok\",\n    \"paladin\",\n    \"pandemic\",\n    \"paper_doll\",\n    \"patch\",\n    \"patriot\",\n    \"payback\",\n    \"penance\",\n    \"pepper_potts\",\n    \"pestilence\",\n    \"pet_avengers\",\n    \"pete_wisdom\",\n    \"peter_parker\",\n    \"peter_quill\",\n    \"phalanx\",\n    \"phantom_reporter\",\n    \"phil_sheldon\",\n    \"photon\",\n    \"piledriver\",\n    \"pixie\",\n    \"plazm\",\n    \"polaris\",\n    \"post\",\n    \"power_man\",\n    \"power_pack\",\n    \"praxagora\",\n    \"preak\",\n    \"pretty_boy\",\n    \"pride\",\n    \"prima\",\n    \"princess_powerful\",\n    \"prism\",\n    \"prodigy\",\n    \"proemial_gods\",\n    \"professor_monster\",\n    \"proteus\",\n    \"proudstar\",\n    \"prowler\",\n    \"psylocke\",\n    \"psynapse\",\n    \"puck\",\n    \"puff_adder\",\n    \"puma\",\n    \"protector\",\n    \"puppet_master\",\n    \"purifiers\",\n    \"purple_man\",\n    \"pyro\",\n    \"quasar\",\n    \"quasimodo\",\n    \"queen_noir\",\n    \"quentin_quire\",\n    \"quicksilver\",\n    \"rachel_grey\",\n    \"radioactive_man\",\n    \"rafael_vega\",\n    \"peace\",\n    \"raider\",\n    \"randall\",\n    \"randall_flagg\",\n    \"random\",\n    \"rattler\",\n    \"ravenous\",\n    \"rawhide_kid\",\n    \"raza\",\n    \"reaper\",\n    \"reavers\",\n    \"red_ghost\",\n    \"red_hulk\",\n    \"red_shift\",\n    \"red_skull\",\n    \"red_wolf\",\n    \"redwing\",\n    \"reptil\",\n    \"retro_girl\",\n    \"revanche\",\n    \"rhino\",\n    \"rhodey\",\n    \"richard_fisk\",\n    \"rick_jones\",\n    \"ricochet\",\n    \"rictor\",\n    \"riptide\",\n    \"risque\",\n    \"robbie_robertson\",\n    \"robin_chapel\",\n    \"rocket_raccoon\",\n    \"rocket_racer\",\n    \"rockslide\",\n    \"rogue\",\n    \"roland_deschain\",\n    \"romulus\",\n    \"ronan\",\n    \"roughhouse\",\n    \"roulette\",\n    \"roxanne_simpson\",\n    \"rumiko_fujikawa\",\n    \"runaways\",\n    \"russian\",\n    \"sabra\",\n    \"sabretooth\",\n    \"sage\",\n    \"sally_floyd\",\n    \"salo\",\n    \"sandman\",\n    \"santa_claus\",\n    \"saracen\",\n    \"sasquatch\",\n    \"satana\",\n    \"sauron\",\n    \"scalphunter\",\n    \"scarecrow\",\n    \"scarlet_spider\",\n    \"scarlet_witch\",\n    \"scorpion\",\n    \"scourge\",\n    \"scrambler\",\n    \"melody\",\n    \"screwball\",\n    \"sebastian_shaw\",\n    \"secret_warriors\",\n    \"selene\",\n    \"senator_kelly\",\n    \"sentinel\",\n    \"sentinels\",\n    \"sentry\",\n    \"ser_duncan\",\n    \"serpent_society\",\n    \"sersi\",\n    \"shadow_king\",\n    \"shadowcat\",\n    \"shaman\",\n    \"shape\",\n    \"shard\",\n    \"sharon_carter\",\n    \"sharon_ventura\",\n    \"shatterstar\",\n    \"shen\",\n    \"sheva_callister\",\n    \"shinko_yamashiro\",\n    \"shinobi_shaw\",\n    \"shiva\",\n    \"shiver_man\",\n    \"shocker\",\n    \"shockwave\",\n    \"shooting_star\",\n    \"shotgun\",\n    \"shriek\",\n    \"silhouette\",\n    \"silk_fever\",\n    \"silver_centurion\",\n    \"silver_fox\",\n    \"silver_sable\",\n    \"silver_samurai\",\n    \"silver_surfer\",\n    \"silverclaw\",\n    \"silvermane\",\n    \"sinister_six\",\n    \"sir_ram\",\n    \"siren\",\n    \"sister_grimm\",\n    \"skaar\",\n    \"skin\",\n    \"skreet\",\n    \"skrulls\",\n    \"skullbuster\",\n    \"slapstick\",\n    \"slayback\",\n    \"sleeper\",\n    \"sleepwalker\",\n    \"slipstream\",\n    \"slyde\",\n    \"smasher\",\n    \"smiling_tiger\",\n    \"snowbird\",\n    \"solo\",\n    \"songbird\",\n    \"spacker_dave\",\n    \"spectrum\",\n    \"speed\",\n    \"speed_demon\",\n    \"speedball\",\n    \"spencer_smythe\",\n    \"sphinx\",\n    \"spiral\",\n    \"spirit\",\n    \"spitfire\",\n    \"spot\",\n    \"sprite\",\n    \"spyke\",\n    \"squadron_sinister\",\n    \"squadron_supreme\",\n    \"squirrel_girl\",\n    \"star_brand\",\n    \"starbolt\",\n    \"stardust\",\n    \"starfox\",\n    \"starhawk\",\n    \"starjammers\",\n    \"stark_industries\",\n    \"stature\",\n    \"steel_serpent\",\n    \"stellaris\",\n    \"stepford_cuckoos\",\n    \"stephen_strange\",\n    \"steve_rogers\",\n    \"stick\",\n    \"stingray\",\n    \"stone_men\",\n    \"storm\",\n    \"stranger\",\n    \"strong_guy\",\n    \"stryfe\",\n    \"sue_storm\",\n    \"sugar_man\",\n    \"sumo\",\n    \"sunfire\",\n    \"sunset_bain\",\n    \"sunspot\",\n    \"supernaut\",\n    \"supreme_intelligence\",\n    \"surge\",\n    \"susan_delgado\",\n    \"swarm\",\n    \"sway\",\n    \"switch\",\n    \"swordsman\",\n    \"synch\",\n    \"tag\",\n    \"talisman\",\n    \"talkback\",\n    \"talon\",\n    \"talos\",\n    \"tana_nile\",\n    \"tarantula\",\n    \"tarot\",\n    \"taskmaster\",\n    \"tattoo\",\n    \"ted_forrester\",\n    \"tempest\",\n    \"tenebrous\",\n    \"terrax\",\n    \"valor\",\n    \"texas_twister\",\n    \"thaddeus_ross\",\n    \"thanos\",\n    \"the_anarchist\",\n    \"the_call\",\n    \"the_captain\",\n    \"the_enforcers\",\n    \"the_executioner\",\n    \"the_fallen\",\n    \"the_fury\",\n    \"the_hand\",\n    \"the_hood\",\n    \"the_hunter\",\n    \"the_initiative\",\n    \"the_leader\",\n    \"the_liberteens\",\n    \"the_order\",\n    \"the_phantom\",\n    \"the_professor\",\n    \"the_renegades\",\n    \"the_santerians\",\n    \"the_spike\",\n    \"the_stranger\",\n    \"the_twelve\",\n    \"the_watchers\",\n    \"thena\",\n    \"thing\",\n    \"thor\",\n    \"thor_girl\",\n    \"thunderball\",\n    \"thunderbird\",\n    \"thunderbolt\",\n    \"thunderbolt_ross\",\n    \"thunderbolts\",\n    \"thundra\",\n    \"tiger_shark\",\n    \"tigra\",\n    \"timeslip\",\n    \"tinkerer\",\n    \"titania\",\n    \"titanium_man\",\n    \"toad\",\n    \"toad_men\",\n    \"tomas\",\n    \"tombstone\",\n    \"tomorrow_man\",\n    \"tony_stark\",\n    \"toro\",\n    \"toxin\",\n    \"trauma\",\n    \"triathlon\",\n    \"trish_tilby\",\n    \"triton\",\n    \"true_believers\",\n    \"turbo\",\n    \"tusk\",\n    \"tyger_tiger\",\n    \"typhoid_mary\",\n    \"tyrannus\",\n    \"ulik\",\n    \"ultimates\",\n    \"ultimatum\",\n    \"ultimo\",\n    \"ultragirl\",\n    \"ultron\",\n    \"umar\",\n    \"unicorn\",\n    \"union_jack\",\n    \"unus\",\n    \"valeria_richards\",\n    \"valkyrie\",\n    \"vampiro\",\n    \"vance_astro\",\n    \"vanisher\",\n    \"vapor\",\n    \"vargas\",\n    \"vector\",\n    \"veda\",\n    \"vengeance\",\n    \"venom\",\n    \"venus\",\n    \"vermin\",\n    \"vertigo\",\n    \"victor_mancha\",\n    \"vin_gonzales\",\n    \"vindicator\",\n    \"violations\",\n    \"viper\",\n    \"virginia_dare\",\n    \"vision\",\n    \"vivisector\",\n    \"vulcan\",\n    \"vulture\",\n    \"wallflower\",\n    \"wallop\",\n    \"wallow\",\n    \"war_machine\",\n    \"warbird\",\n    \"warbound\",\n    \"warhawk\",\n    \"warlock\",\n    \"warpath\",\n    \"warstar\",\n    \"wasp\",\n    \"weapon_omega\",\n    \"wendell_rand\",\n    \"wendell_vaughn\",\n    \"wendigo\",\n    \"whiplash\",\n    \"whirlwind\",\n    \"whistler\",\n    \"white_queen\",\n    \"white_tiger\",\n    \"whizzer\",\n    \"wiccan\",\n    \"wild_child\",\n    \"wild_pack\",\n    \"wildside\",\n    \"william_stryker\",\n    \"wilson_fisk\",\n    \"wind_dancer\",\n    \"winter_soldier\",\n    \"wither\",\n    \"wolf_cub\",\n    \"wolfpack\",\n    \"wolfsbane\",\n    \"wolverine\",\n    \"wonder_man\",\n    \"wong\",\n    \"wraith\",\n    \"wrecker\",\n    \"wrecking_crew\",\n    \"xavin\",\n    \"xorn\",\n    \"yellow_claw\",\n    \"yellowjacket\",\n    \"young_avengers\",\n    \"zaladane\",\n    \"zaran\",\n    \"zarda\",\n    \"zarek\",\n    \"zeigeist\",\n    \"zemo\",\n    \"zodiak\",\n    \"legend\",\n    \"zuras\",\n    \"zzzax\"\n]\n\nexport function randomAdjective(): string {\n    return adjectives[Math.floor(Math.random() * adjectives.length)]\n}\n\nexport function randomNoun(): string {\n    return nouns[Math.floor(Math.random() * nouns.length)]\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/helpers/randomWords.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/capabilities.ts",
      "content": "/* eslint-disable @typescript-eslint/no-namespace */\nimport * as Permissions from \"@/registry/batua/lib/batua/typebox/permissions\"\nimport * as Primitive from \"@/registry/batua/lib/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/lib/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/lib/batua/typebox/schema\"\n\nexport namespace createAccount {\n    export const Request = Type.Union([\n        Type.Boolean(),\n        Type.Object({\n            chainId: Schema.Optional(Primitive.TypeboxNumber),\n            label: Schema.Optional(Type.String())\n        })\n    ])\n    export type Request = Schema.StaticDecode<typeof Request>\n}\n\nexport namespace grantPermissions {\n    export const Request = Permissions.Request\n    export type Request = Schema.StaticDecode<typeof Request>\n}\n\nexport namespace permissions {\n    export const Request = Type.Object({\n        id: Schema.Optional(Primitive.Hex)\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(Permissions.Permissions)\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/capabilities.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/key.ts",
      "content": "import * as Primitive from \"@/registry/batua/lib/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/lib/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/lib/batua/typebox/schema\"\n\nexport const Base = Type.Object({\n    /** The expiry of the key. */\n    expiry: Primitive.TypeboxNumber,\n    /** The hash of the key. */\n    hash: Primitive.Hex,\n    /** Public key. */\n    publicKey: Primitive.Hex,\n    /** Role. */\n    role: Type.Union([Type.Literal(\"admin\"), Type.Literal(\"session\")]),\n    /** Key type. */\n    type: Type.Union([\n        Type.Literal(\"address\"),\n        Type.Literal(\"p256\"),\n        Type.Literal(\"secp256k1\"),\n        Type.Literal(\"webauthn-p256\")\n    ])\n})\nexport type Base = Schema.StaticDecode<typeof Base>\n\nexport const CallPermissions = Type.Array(\n    Type.Union([\n        Type.Object({\n            signature: Type.String(),\n            to: Primitive.Address\n        }),\n        Type.Object({\n            signature: Type.String(),\n            to: Schema.Optional(Type.Undefined())\n        }),\n        Type.Object({\n            signature: Schema.Optional(Type.Undefined()),\n            to: Primitive.Address\n        })\n    ]),\n    { minItems: 1 }\n)\nexport type CallPermissions = Schema.StaticDecode<typeof CallPermissions>\n\nexport const SignatureVerificationPermission = Type.Object({\n    addresses: Type.Array(Primitive.Address)\n})\nexport type SignatureVerificationPermission = Schema.StaticDecode<\n    typeof SignatureVerificationPermission\n>\n\nexport const SpendPermissions = Type.Array(\n    Type.Object({\n        limit: Primitive.TypeboxBigInt,\n        period: Type.Union([\n            Type.Literal(\"minute\"),\n            Type.Literal(\"hour\"),\n            Type.Literal(\"day\"),\n            Type.Literal(\"week\"),\n            Type.Literal(\"month\"),\n            Type.Literal(\"year\")\n        ]),\n        token: Schema.Optional(Primitive.Address)\n    })\n)\nexport type SpendPermissions = Schema.StaticDecode<typeof SpendPermissions>\n\nexport const Permissions = Type.Object({\n    calls: Schema.Optional(CallPermissions),\n    signatureVerification: Schema.Optional(SignatureVerificationPermission),\n    spend: Schema.Optional(SpendPermissions)\n})\nexport type Permissions = Schema.StaticDecode<typeof Permissions>\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/key.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/permissions.ts",
      "content": "import * as Key from \"@/registry/batua/lib/batua/typebox/key\"\nimport * as Primitive from \"@/registry/batua/lib/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/lib/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/lib/batua/typebox/schema\"\n\nexport const Permissions = Type.Object({\n    address: Primitive.Address,\n    chainId: Schema.Optional(Primitive.TypeboxNumber),\n    expiry: Type.Number(),\n    id: Primitive.Hex,\n    key: Type.Pick(Key.Base, [\"publicKey\", \"type\"]),\n    permissions: Type.Object({\n        calls: Key.CallPermissions,\n        signatureVerification: Schema.Optional(\n            Key.SignatureVerificationPermission\n        ),\n        spend: Schema.Optional(Key.SpendPermissions)\n    })\n})\nexport type Permissions = Schema.StaticDecode<typeof Permissions>\n\nexport const Request = Type.Object({\n    address: Schema.Optional(Primitive.Address),\n    chainId: Schema.Optional(Primitive.TypeboxNumber),\n    expiry: Type.Number({ minimum: 1 }),\n    key: Schema.Optional(Permissions.properties.key),\n    permissions: Permissions.properties.permissions\n})\nexport type Request = Schema.StaticDecode<typeof Request>\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/permissions.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/primitive.ts",
      "content": "import * as Hex_ox from \"ox/Hex\"\n\nimport { Type } from \"@/registry/batua/lib/batua/typebox/schema\"\n\nexport const Address = Type.TemplateLiteral(\"0x${string}\")\nexport const Hex = Type.TemplateLiteral(\"0x${string}\")\nexport const TypeboxNumber = Type.Transform(Hex)\n    .Decode((value) => Hex_ox.toNumber(value))\n    .Encode((value) => Hex_ox.fromNumber(value))\nexport const TypeboxBigInt = Type.Transform(Hex)\n    .Decode((value) => Hex_ox.toBigInt(value))\n    .Encode((value) => Hex_ox.fromNumber(value))\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/primitive.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/request.ts",
      "content": "/* eslint-disable @typescript-eslint/no-namespace */\nimport * as C from \"@/registry/batua/lib/batua/typebox/capabilities\"\nimport * as Permissions from \"@/registry/batua/lib/batua/typebox/permissions\"\nimport * as Primitive from \"@/registry/batua/lib/batua/typebox/primitive\"\nimport * as Schema from \"@/registry/batua/lib/batua/typebox/schema\"\nimport { Type } from \"@/registry/batua/lib/batua/typebox/schema\"\n\nexport namespace eth_accounts {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_accounts\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(Primitive.Address)\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_chainId {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_chainId\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_requestAccounts {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_requestAccounts\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(Primitive.Address)\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_sendTransaction {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_sendTransaction\"),\n        params: Type.Tuple([\n            Type.Object({\n                chainId: Schema.Optional(Primitive.TypeboxNumber),\n                data: Schema.Optional(Primitive.Hex),\n                from: Primitive.Address,\n                to: Primitive.Address,\n                value: Schema.Optional(Primitive.TypeboxBigInt)\n            })\n        ])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace eth_signTypedData_v4 {\n    export const Request = Type.Object({\n        method: Type.Literal(\"eth_signTypedData_v4\"),\n        params: Type.Tuple([Primitive.Address, Type.String()])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_createAccount {\n    export const Parameters = Type.Intersect([\n        Type.Object({\n            chainId: Schema.Optional(Primitive.TypeboxNumber),\n            label: Schema.Optional(Type.String())\n        })\n    ])\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_createAccount\"),\n        params: Schema.Optional(Type.Tuple([Parameters]))\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const ResponseCapabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Response)\n    })\n    export type ResponseCapabilities = Schema.StaticDecode<\n        typeof ResponseCapabilities\n    >\n\n    export const Response = Type.Object({\n        address: Primitive.Address,\n        capabilities: Schema.Optional(ResponseCapabilities)\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_grantPermissions {\n    export const Parameters = Permissions.Request\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_grantPermissions\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Permissions.Permissions\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_permissions {\n    export const Parameters = Type.Object({\n        address: Schema.Optional(Primitive.Address)\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_permissions\"),\n        params: Schema.Optional(Type.Tuple([Parameters]))\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = C.permissions.Response\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_prepareUpgradeAccount {\n    export const Capabilities = Type.Object({\n        grantPermissions: Schema.Optional(C.grantPermissions.Request)\n    })\n    export type Capabilities = Schema.StaticDecode<typeof Capabilities>\n\n    export const Parameters = Type.Object({\n        address: Primitive.Address,\n        chainId: Schema.Optional(Primitive.TypeboxNumber),\n        capabilities: Schema.Optional(Capabilities),\n        label: Schema.Optional(Type.String())\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_prepareUpgradeAccount\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Object({\n        context: Type.Unknown(),\n        signPayloads: Type.Array(Primitive.Hex)\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace experimental_revokePermissions {\n    export const Parameters = Type.Object({\n        address: Schema.Optional(Primitive.Address),\n        id: Primitive.Hex\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_revokePermissions\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = undefined\n}\n\nexport namespace experimental_upgradeAccount {\n    export const Parameters = Type.Object({\n        context: Type.Unknown(),\n        signatures: Type.Array(Primitive.Hex)\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"experimental_upgradeAccount\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const ResponseCapabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Response)\n    })\n    export type ResponseCapabilities = Schema.StaticDecode<\n        typeof ResponseCapabilities\n    >\n\n    export const Response = Type.Object({\n        address: Primitive.Address,\n        capabilities: Schema.Optional(ResponseCapabilities)\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace personal_sign {\n    export const Request = Type.Object({\n        method: Type.Literal(\"personal_sign\"),\n        params: Type.Tuple([Primitive.Hex, Primitive.Address])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n}\n\nexport namespace batua_ping {\n    export const Request = Type.Object({\n        method: Type.Literal(\"batua_ping\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Literal(\"pong\")\n}\n\nexport namespace wallet_connect {\n    export const Capabilities = Type.Object({\n        createAccount: Schema.Optional(C.createAccount.Request),\n        grantPermissions: Schema.Optional(C.grantPermissions.Request),\n        selectAccount: Schema.Optional(Type.Boolean())\n    })\n    export type Capabilities = Schema.StaticDecode<typeof Capabilities>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_connect\"),\n        params: Schema.Optional(\n            Type.Tuple([\n                Type.Object({\n                    capabilities: Schema.Optional(Capabilities)\n                })\n            ])\n        )\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const ResponseCapabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Response)\n    })\n    export type ResponseCapabilities = Schema.StaticDecode<\n        typeof ResponseCapabilities\n    >\n\n    export const Response = Type.Object({\n        accounts: Type.Array(\n            Type.Object({\n                address: Primitive.Address,\n                capabilities: Schema.Optional(ResponseCapabilities)\n            })\n        )\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_disconnect {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_disconnect\"),\n        params: Schema.Optional(Type.Undefined())\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = undefined\n}\n\nexport namespace wallet_getCallsStatus {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_getCallsStatus\"),\n        params: Type.Tuple([Primitive.Hex])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Object({\n        receipts: Schema.Optional(\n            Type.Array(\n                Type.Object({\n                    logs: Type.Array(\n                        Type.Object({\n                            address: Primitive.Address,\n                            data: Primitive.Hex,\n                            topics: Type.Array(Primitive.Hex)\n                        })\n                    ),\n                    status: Primitive.Hex,\n                    blockHash: Primitive.Hex,\n                    blockNumber: Primitive.Hex,\n                    gasUsed: Primitive.Hex,\n                    transactionHash: Primitive.Hex\n                })\n            )\n        ),\n        status: Type.Union([Type.Literal(\"CONFIRMED\"), Type.Literal(\"PENDING\")])\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_getCapabilities {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_getCapabilities\"),\n        params: Type.Union([\n            Type.Tuple([Primitive.Address, Type.Array(Primitive.Hex)]),\n            Type.Tuple([Primitive.Address])\n        ])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Record(\n        Primitive.Hex,\n        Type.Object({\n            atomicBatch: Type.Object({\n                supported: Type.Boolean()\n            }),\n            createAccount: Type.Object({\n                supported: Type.Boolean()\n            }),\n            permissions: Type.Object({\n                supported: Type.Boolean()\n            })\n        })\n    )\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_prepareCalls {\n    export const Capabilities = Type.Object({\n        permissions: Schema.Optional(C.permissions.Request)\n    })\n    export type Capabilities = Schema.StaticDecode<typeof Capabilities>\n\n    export const Parameters = Type.Object({\n        calls: Type.Array(\n            Type.Object({\n                to: Primitive.Address,\n                data: Schema.Optional(Primitive.Hex),\n                value: Schema.Optional(Primitive.TypeboxBigInt)\n            })\n        ),\n        key: Type.Object({\n            publicKey: Primitive.Hex,\n            type: Type.Union([\n                Type.Literal(\"p256\"),\n                Type.Literal(\"secp256k1\"),\n                Type.Literal(\"webauthn-p256\"),\n                Type.Literal(\"address\")\n            ])\n        }),\n        capabilities: Schema.Optional(Capabilities),\n        chainId: Schema.Optional(Primitive.TypeboxNumber),\n        from: Schema.Optional(Primitive.Address),\n        version: Schema.Optional(Type.String())\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_prepareCalls\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Object({\n        capabilities: Schema.Optional(Type.Record(Type.String(), Type.Any())),\n        chainId: Primitive.Hex,\n        context: Type.Object({\n            account: Type.Object({\n                address: Primitive.Address,\n                type: Type.Literal(\"delegated\")\n            }),\n            calls: Parameters.properties.calls,\n            nonce: Primitive.TypeboxBigInt\n        }),\n        digest: Primitive.Hex,\n        key: Parameters.properties.key\n    })\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_sendCalls {\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_sendCalls\"),\n        params: Type.Tuple([Type.Omit(wallet_prepareCalls.Parameters, [\"key\"])])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Primitive.Hex\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_sendPreparedCalls {\n    export const Parameters = Type.Object({\n        capabilities: wallet_prepareCalls.Response.properties.capabilities,\n        chainId: Primitive.Hex,\n        context: wallet_prepareCalls.Response.properties.context,\n        key: wallet_prepareCalls.Response.properties.key,\n        signature: Primitive.Hex\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_sendPreparedCalls\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = Type.Array(\n        Type.Object({\n            id: Type.String(),\n            capabilities: Schema.Optional(\n                Type.Record(Type.String(), Type.Any())\n            )\n        })\n    )\n    export type Response = Schema.StaticDecode<typeof Response>\n}\n\nexport namespace wallet_revokePermissions {\n    export const Parameters = Type.Object({\n        eth_accounts: Type.Array(Type.Any())\n    })\n    export type Parameters = Schema.StaticDecode<typeof Parameters>\n\n    export const Request = Type.Object({\n        method: Type.Literal(\"wallet_revokePermissions\"),\n        params: Type.Tuple([Parameters])\n    })\n    export type Request = Schema.StaticDecode<typeof Request>\n\n    export const Response = undefined\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/request.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/rpc.ts",
      "content": "import * as Json from \"ox/Json\"\nimport * as RpcResponse from \"ox/RpcResponse\"\n\nimport type { Union } from \"@sinclair/typebox/type\"\nimport * as RpcRequest from \"@/registry/batua/lib/batua/typebox/request\"\nimport {\n    type StaticDecode,\n    type StaticEncode,\n    Type,\n    Value\n} from \"@/registry/batua/lib/batua/typebox/schema\"\n\nimport { eth_accounts } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { eth_chainId } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { eth_requestAccounts } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { eth_sendTransaction } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { eth_signTypedData_v4 } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { experimental_permissions } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { experimental_createAccount } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { experimental_grantPermissions } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { experimental_prepareUpgradeAccount } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { experimental_revokePermissions } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { experimental_upgradeAccount } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { personal_sign } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { batua_ping } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_connect } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_disconnect } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_getCallsStatus } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_getCapabilities } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_prepareCalls } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_sendCalls } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_sendPreparedCalls } from \"@/registry/batua/lib/batua/typebox/request\"\nimport { wallet_revokePermissions } from \"@/registry/batua/lib/batua/typebox/request\"\n\nexport {\n    eth_accounts,\n    eth_chainId,\n    eth_requestAccounts,\n    eth_sendTransaction,\n    eth_signTypedData_v4,\n    experimental_permissions,\n    experimental_createAccount,\n    experimental_grantPermissions,\n    experimental_prepareUpgradeAccount,\n    experimental_revokePermissions,\n    experimental_upgradeAccount,\n    personal_sign,\n    batua_ping,\n    wallet_connect,\n    wallet_disconnect,\n    wallet_getCallsStatus,\n    wallet_getCapabilities,\n    wallet_prepareCalls,\n    wallet_sendCalls,\n    wallet_sendPreparedCalls,\n    wallet_revokePermissions\n}\n\nexport const Request = Type.Union([\n    RpcRequest.eth_accounts.Request,\n    RpcRequest.eth_chainId.Request,\n    RpcRequest.eth_requestAccounts.Request,\n    RpcRequest.eth_sendTransaction.Request,\n    RpcRequest.eth_signTypedData_v4.Request,\n    RpcRequest.experimental_permissions.Request,\n    RpcRequest.experimental_createAccount.Request,\n    RpcRequest.experimental_grantPermissions.Request,\n    RpcRequest.experimental_prepareUpgradeAccount.Request,\n    RpcRequest.experimental_revokePermissions.Request,\n    RpcRequest.experimental_upgradeAccount.Request,\n    RpcRequest.personal_sign.Request,\n    RpcRequest.batua_ping.Request,\n    RpcRequest.wallet_connect.Request,\n    RpcRequest.wallet_disconnect.Request,\n    RpcRequest.wallet_getCallsStatus.Request,\n    RpcRequest.wallet_getCapabilities.Request,\n    RpcRequest.wallet_prepareCalls.Request,\n    RpcRequest.wallet_sendCalls.Request,\n    RpcRequest.wallet_sendPreparedCalls.Request,\n    RpcRequest.wallet_revokePermissions.Request\n])\n\nexport function parseRequest(request: unknown): parseRequest.ReturnType {\n    const raw = Value.Convert(Request, request)\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const method = RpcRequest[(raw as any).method as keyof typeof RpcRequest]\n    if (method) {\n        const error = Value.Errors(method.Request, raw).First()\n        const message = [\n            error?.message,\n            \"\",\n            `Path: ${error?.path.slice(1).replaceAll(\"/\", \".\")}`,\n            error?.value && `Value: ${Json.stringify(error.value)}`\n        ]\n            .filter((x) => typeof x === \"string\")\n            .join(\"\\n\")\n        if (error) throw new RpcResponse.InvalidParamsError({ message })\n    }\n\n    Value.Assert(Request, raw)\n    const _decoded = Value.Decode(Request, raw)\n\n    return {\n        ...raw,\n        _decoded\n    } as never\n}\n\n/* eslint-disable @typescript-eslint/no-namespace */\nexport declare namespace parseRequest {\n    export type ReturnType = typeof Request extends Union<infer U>\n        ? {\n              [K in keyof U]: StaticEncode<U[K]> & {\n                  _decoded: StaticDecode<U[K]>\n              }\n          }[number]\n        : never\n}\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/rpc.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/schema.ts",
      "content": "/* eslint-disable @typescript-eslint/no-namespace */\nimport {\n    Kind,\n    type StaticDecode as StaticDecode_typebox,\n    type StaticEncode as StaticEncode_typebox,\n    type Static as Static_typebox,\n    type TNever,\n    type TOptional,\n    type TSchema,\n    type TUndefined,\n    type TUnion,\n    Type\n} from \"@sinclair/typebox/type\"\nexport { Type } from \"@sinclair/typebox/type\"\nexport { Value, Encode, Decode } from \"@sinclair/typebox/value\"\n\nimport type { DeepReadonly } from \"@/registry/batua/lib/batua/typebox/types\"\n\nexport function OneOf<schemas extends TSchema[]>(\n    schemas: [...schemas]\n): OneOf.ReturnType<schemas> {\n    return Type.Union(schemas) as never\n}\n\nexport declare namespace OneOf {\n    type OneOfStatic<T extends TSchema[], P extends unknown[]> = {\n        [K in keyof T]: T[K] extends TSchema ? Static_typebox<T[K], P> : never\n    }[number]\n\n    export interface ReturnType<T extends TSchema[] = TSchema[]>\n        extends TSchema {\n        [Kind]: \"Union\"\n        static: OneOfStatic<T, this[\"params\"]>\n    }\n\n    export type OneOf<T extends TSchema[]> = T extends []\n        ? TNever\n        : T extends [TSchema]\n          ? T[0]\n          : ReturnType<T>\n}\n\nexport function Optional<schema extends TSchema>(\n    schema: schema\n): TOptional<TUnion<[schema, TUndefined]>> {\n    return Type.Optional(schema) as never\n}\n\nexport type StaticDecode<\n    T extends TSchema,\n    P extends unknown[] = []\n> = DeepReadonly<StaticDecode_typebox<T, P>>\n\nexport type StaticEncode<\n    T extends TSchema,\n    P extends unknown[] = []\n> = DeepReadonly<StaticEncode_typebox<T, P>>\n\nexport type Static<T extends TSchema, P extends unknown[] = []> = DeepReadonly<\n    Static_typebox<T, P>\n>\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/schema.ts"
    },
    {
      "path": "registry/batua/lib/batua/typebox/types.ts",
      "content": "/** Combines members of an intersection into a readable type. */\n// https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg\nexport type Compute<type> = { [key in keyof type]: type[key] } & unknown\n\ndeclare const symbol: unique symbol\n\n/**\n * Creates a branded type of `T` with the brand `U`.\n *\n * @example\n * ```ts\n * type Result = Branded<string, 'foo'>\n * //   ^? type Result = string & { [symbol]: 'foo' }\n * ```\n */\nexport type Branded<T, U> = T & { [symbol]: U }\n\n/**\n * Filters out all members of `T` that are not `P`\n *\n * @example\n * ```ts\n * type Result = Filter<['a', 'b', 'c'], 'b'>\n * //   ^? type Result = ['a', 'c']\n * ```\n *\n * @internal\n */\nexport type Filter<\n    T extends readonly unknown[],\n    P,\n    Acc extends readonly unknown[] = []\n> = T extends readonly [infer F, ...infer Rest extends readonly unknown[]]\n    ? [F] extends [P]\n        ? Filter<Rest, P, [...Acc, F]>\n        : Filter<Rest, P, Acc>\n    : readonly [...Acc]\n\n/**\n * Checks if `T` can be narrowed further than `U`\n *\n * @example\n * ```ts\n * type Result = IsNarrowable<'foo', string>\n * //   ^? true\n * ```\n */\nexport type IsNarrowable<T, U> = IsNever<\n    (T extends U ? true : false) & (U extends T ? false : true)\n> extends true\n    ? false\n    : true\n\n/**\n * Checks if `T` is `never`\n *\n * @example\n * ```ts\n * type Result = IsNever<never>\n * //   ^? type Result = true\n * ```\n */\nexport type IsNever<T> = [T] extends [never] ? true : false\n\n/**\n * Removes `readonly` from all properties of an object.\n *\n * @internal\n */\nexport type Mutable<type extends object> = {\n    -readonly [key in keyof type]: type[key]\n}\n\n/**\n * Evaluates boolean \"or\" condition for `T` properties.\n *\n * * @example\n * ```ts\n * type Result = Or<[false, true, false]>\n * //   ^? type Result = true\n * ```\n *\n * @example\n * ```ts\n * type Result = Or<[false, false, false]>\n * //   ^? type Result = false\n * ```\n *\n * @internal\n */\nexport type Or<T extends readonly unknown[]> = T extends readonly [\n    infer Head,\n    ...infer Tail\n]\n    ? Head extends true\n        ? true\n        : Or<Tail>\n    : false\n\n/**\n * Checks if `T` is `undefined`\n *\n * @example\n * ```ts\n * type Result = IsUndefined<undefined>\n * //   ^? type Result = true\n * ```\n *\n * @internal\n */\nexport type IsUndefined<T> = [undefined] extends [T] ? true : false\n\n/**\n * Checks if type `T` is the `unknown` type.\n *\n * @internal\n */\nexport type IsUnknown<T> = unknown extends T\n    ? [T] extends [null]\n        ? false\n        : true\n    : false\n\n/** @internal */\nexport type MaybePromise<T> = T | Promise<T>\n\n/**\n * Makes attributes on the type T required if required is true.\n *\n * @example\n * ```ts\n * MaybeRequired<{ a: string, b?: number }, true>\n * // { a: string, b: number }\n *\n * MaybeRequired<{ a: string, b?: number }, false>\n * // { a: string, b?: number }\n * ```\n *\n * @internal\n */\nexport type MaybeRequired<T, required extends boolean> = required extends true\n    ? ExactRequired<T>\n    : T\n\n/**\n * Assigns the properties of U onto T.\n *\n * @example\n * ```ts\n * Assign<{ a: string, b: number }, { a: undefined, c: boolean }>\n * // { a: undefined, b: number, c: boolean }\n * ```\n *\n * @internal\n */\nexport type Assign<T, U> = Assign_inner<T, U> & U\n\n/** @internal */\nexport type Assign_inner<T, U> = {\n    [K in keyof T as K extends keyof U\n        ? U[K] extends void\n            ? never\n            : K\n        : K]: K extends keyof U ? U[K] : T[K]\n}\n\n/**\n * Constructs a type by excluding `undefined` from `T`.\n *\n * @example\n * ```ts\n * NoUndefined<string | undefined>\n * // string\n * ```\n *\n * @internal\n */\nexport type NoUndefined<T> = T extends undefined ? never : T\n\n/**\n * Strict version of built-in Omit type\n *\n * @internal\n */\nexport type Omit<type, keys extends keyof type> = Pick<\n    type,\n    Exclude<keyof type, keys>\n>\n\n/**\n * Creates a type that is a partial of T, but with the required keys K.\n *\n * @example\n * ```ts\n * PartialBy<{ a: string, b: number }, 'a'>\n * // { a?: string, b: number }\n * ```\n *\n * @internal\n */\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> &\n    ExactPartial<Pick<T, K>>\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\n/**\n * Creates a type that is T with the required keys K.\n *\n * @example\n * ```ts\n * RequiredBy<{ a?: string, b: number }, 'a'>\n * // { a: string, b: number }\n * ```\n *\n * @internal\n */\nexport type RequiredBy<T, K extends keyof T> = Omit<T, K> &\n    ExactRequired<Pick<T, K>>\n\n/**\n * Returns truthy if `array` contains `value`.\n *\n * @example\n * ```ts\n * Some<[1, 2, 3], 2>\n * // true\n * ```\n *\n * @internal\n */\nexport type Some<\n    array extends readonly unknown[],\n    value\n> = array extends readonly [value, ...unknown[]]\n    ? true\n    : array extends readonly [unknown, ...infer rest]\n      ? Some<rest, value>\n      : false\n\n/**\n * Prints custom error message\n *\n * @param messages - Error message\n * @returns Custom error message\n *\n * @example\n * ```ts\n * type Result = TypeErrorMessage<'Custom error message'>\n * //   ^? type Result = ['Error: Custom error message']\n * ```\n */\nexport type TypeErrorMessage<messages extends string | string[]> =\n    messages extends string\n        ? [\n              // Surrounding with array to prevent `messages` from being widened to `string`\n              `Error: ${messages}`\n          ]\n        : {\n              [key in keyof messages]: messages[key] extends infer message extends\n                  string\n                  ? `Error: ${message}`\n                  : never\n          }\n\n/** @internal */\nexport type UnionToTuple<\n    union,\n    ///\n    last = LastInUnion<union>\n> = [union] extends [never] ? [] : [...UnionToTuple<Exclude<union, last>>, last]\n\n/** @internal */\nexport type LastInUnion<U> = UnionToIntersection<\n    U extends unknown ? (x: U) => 0 : never\n> extends (x: infer l) => 0\n    ? l\n    : never\n\n/** @internal */\nexport type UnionToIntersection<union> = (\n    union extends unknown\n        ? (arg: union) => 0\n        : never\n) extends (arg: infer i) => 0\n    ? i\n    : never\n\n/** @internal */\nexport type IsUnion<\n    union,\n    ///\n    union2 = union\n> = union extends union2 ? ([union2] extends [union] ? false : true) : never\n\n/** @internal */\nexport type MaybePartial<\n    type,\n    enabled extends boolean | undefined\n> = enabled extends true ? Compute<ExactPartial<type>> : type\n\nexport type ExactPartial<type> = {\n    [key in keyof type]?: type[key] | undefined\n}\n\n/** @internal */\nexport type ExactRequired<type> = {\n    [key in keyof type]-?: Exclude<type[key], undefined>\n}\n\nexport type OneOf<\n    union extends object,\n    fallback extends object | undefined = undefined,\n    ///\n    keys extends KeyofUnion<union> = KeyofUnion<union>\n> = union extends infer item\n    ? Compute<\n          item & {\n              [key in Exclude<keys, keyof item>]?: fallback extends object\n                  ? key extends keyof fallback\n                      ? fallback[key]\n                      : undefined\n                  : undefined\n          }\n      >\n    : never\n\n/** @internal */\nexport type KeyofUnion<type> = type extends type ? keyof type : never\n\n/** @internal */\nexport type Undefined<type> = {\n    [key in keyof type]?: undefined\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Loose types\n\n/**\n * Loose version of {@link Omit}\n * @internal\n */\nexport type LooseOmit<type, keys extends string> = Pick<\n    type,\n    Exclude<keyof type, keys>\n>\n\n///////////////////////////////////////////////////////////////////////////\n// Union types\n\n/** @internal */\nexport type UnionCompute<type> = type extends object ? Compute<type> : type\n\n/** @internal */\nexport type UnionLooseOmit<type, keys extends string> = type extends any\n    ? LooseOmit<type, keys>\n    : never\n\n/**\n * Construct a type with the properties of union type T except for those in type K.\n * @example\n * ```ts\n * type Result = UnionOmit<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>\n * // { b: number } | { b: undefined, c: number }\n * ```\n *\n * @internal\n */\nexport type UnionOmit<type, keys extends keyof type> = type extends any\n    ? Omit<type, keys>\n    : never\n\n/**\n * Construct a type with the properties of union type T except for those in type K.\n * @example\n * ```ts\n * type Result = UnionOmit<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>\n * // { b: number } | { b: undefined, c: number }\n * ```\n *\n * @internal\n */\nexport type UnionPick<type, keys extends keyof type> = type extends any\n    ? Pick<type, keys>\n    : never\n\n/**\n * Creates a type that is a partial of T, but with the required keys K.\n *\n * @example\n * ```ts\n * PartialBy<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>\n * // { a?: string, b: number } | { a?: string, b: undefined, c: number }\n * ```\n *\n * @internal\n */\nexport type UnionPartialBy<T, K extends keyof T> = T extends any\n    ? PartialBy<T, K>\n    : never\n\n/**\n * Creates a type that is T with the required keys K.\n *\n * @example\n * ```ts\n * RequiredBy<{ a?: string, b: number } | { a?: string, c?: number }, 'a'>\n * // { a: string, b: number } | { a: string, c?: number }\n * ```\n *\n * @internal\n */\nexport type UnionRequiredBy<T, K extends keyof T> = T extends any\n    ? RequiredBy<T, K>\n    : never\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\ntype Builtin = Primitive | Date | Error | RegExp\n\nexport type DeepReadonly<T> = T extends Builtin\n    ? T\n    : IsUnknown<T> extends true\n      ? T\n      : T extends object\n        ? Readonly<{\n              [K in keyof T]: T[K] extends Primitive ? T[K] : DeepReadonly<T[K]>\n          }>\n        : T extends Array<infer U>\n          ? U extends Primitive\n              ? Readonly<Array<U>>\n              : Readonly<Array<DeepReadonly<U>>>\n          : never\n",
      "type": "registry:lib",
      "target": "lib/batua/typebox/types.ts"
    }
  ],
  "categories": [
    "wallet",
    "ethereum",
    "account-abstraction"
  ]
};
